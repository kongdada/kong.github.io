<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kong&#39;Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kongdada.github.io/"/>
  <updated>2020-01-13T03:42:26.993Z</updated>
  <id>https://kongdada.github.io/</id>
  
  <author>
    <name>Waterkong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端json传参，后端spring如何承接</title>
    <link href="https://kongdada.github.io/2020/01/11/json4spring/"/>
    <id>https://kongdada.github.io/2020/01/11/json4spring/</id>
    <published>2020-01-11T07:27:55.000Z</published>
    <updated>2020-01-13T03:42:26.993Z</updated>
    
    <content type="html"><![CDATA[<p>第一篇公众号就讲个很简单的问题吧。前些天重构中前端传过来的参数突然就接受不到了。究其根本就是前端同学统一换了参数的提交格式，从 application/x-www-form-urlencoded 更换成 application/json。一句话解释本文就是 application/json 需要搭配 @RequestBody 使用。<br><a id="more"></a></p><h4 id="一点点唠叨"><a href="#一点点唠叨" class="headerlink" title="一点点唠叨"></a>一点点唠叨</h4><p>一直在想第一篇文章应该写什么，写点最近踩得坑还是最近学的东西还是工作内容，生活感悟，一时间无从下手。同时距离上一篇博客过去了已经 8 个月了，上一篇还是在从老东家走了之后的总结和一些感想。现在想来自己还是不能跳出这个循环，被社会毒打，要奋发图强，然后再回归正常生活，再变成一个懒鬼。但是被毒打之后还是会留给你一点点的启发的，比如开始点源码的技能树，也比如更加有一些危机感。做新手程序员，最好的成长之路还是大量的写代码，大量的阅读业务代码，不懂就问问同事。努力承担更多的责任，干更多事情，必然会成长的。这叫干好自己的工作，理解自己的业务。然后再开始思考学点新东西。如果不知道学什么就从 JDK 源代码开始吧，然后学习缓存 Redis，再来一个中间件 kafka。如果这几个东西都学会怎么使用了，运行机制是怎样的，再看看源码是怎么实现的。这就比很多人都强了，也不着急一步一步来吧。</p><h4 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h4><p>第一篇公众号就讲个很简单的问题吧。前些天重构中前端传过来的参数突然就接受不到了。究其根本就是前端同学统一换了参数的提交格式，从 application/x-www-form-urlencoded 更换成 application/json。一句话解释本文就是 application/json 需要搭配 @RequestBody 使用。<br>前端 json 传参，后端 spring 如何承接<br>前端使用 application/json 传参，分两部分 post 请求和 get 请求，因为这两个不太一样。</p><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>针对 post 请求，后端必须使用@RequestBody 修饰你自定义的实体。<br>修饰自定义的一个实例来接受：例如 BaseDTO，即使只有一个字段也必须写成一个自定义对象；spring 才能将前端传来的参数转化进我们的对象。这儿强调一点，包装类例如：Long Integer  也必须再包一层，就是把这些包装类放在一个自定义实体中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    @RequestMapping(&quot;/demo/c&quot;)</span><br><span class="line">    public String cDemo(@RequestBody Demo demo) &#123;</span><br><span class="line">        return JSON.toJSONString(demo);</span><br><span class="line">    &#125;</span><br><span class="line">备注：post请求，参数放在Request body中</span><br></pre></td></tr></table></figure></p><p>修饰一个 MAP&lt;String, Object&gt;，这样也能正确接收到前端传来的参数，但是使用起来还要通过字段名来获取，比较麻烦。但是，有一些场景很好用，例如不确定前端要传几个参数时，这种写法就派上了用场，不论前端传多少参数，统统接收就好。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   @RequestMapping(&quot;/demo/a&quot;)</span><br><span class="line">   public String aDemo(@RequestBody Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">       return JSON.toJSONString(map);</span><br><span class="line">   &#125;</span><br><span class="line">备注：post请求，参数放在Request body中</span><br></pre></td></tr></table></figure></p><h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><ol><li><p>针对 get 请求，一般来说 get 请求会将参数拼接在 URL 后面，这种直接用实体就能接受，@RequestParam 用也可以，不用也可以，只有一个字段，直接用包装类接受也可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/demo/f&quot;)</span><br><span class="line">public String fDemo(@RequestParam Long demo) &#123;</span><br><span class="line">    return JSON.toJSONString(demo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;/demo/g&quot;)</span><br><span class="line">public String gDemo(Long demo) &#123;</span><br><span class="line">    return JSON.toJSONString(demo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">备注：GET请求，参数放在Request Params中</span><br></pre></td></tr></table></figure></li><li><p>但是也有同学不走寻常路，他使用的是 get 请求，但是把参数放在 requestBody 里面。这就必须要跟 POST 请求一样处理了，加@RequestBody 修饰自定义实体，包装类也需要再使用自定义对象包一层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    @RequestMapping(&quot;/demo/c&quot;)</span><br><span class="line">    public String cDemo(@RequestBody Demo demo) &#123;</span><br><span class="line">        return JSON.toJSONString(demo);</span><br><span class="line">    &#125;</span><br><span class="line">备注：GET请求，参数放在Request body中</span><br></pre></td></tr></table></figure></li></ol><h5 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h5><p>可以放在自己的 SpringBoot 项目中，然后拿 postman 测试一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestDemo &#123;</span><br><span class="line">    @RequestMapping(&quot;/demo/a&quot;)</span><br><span class="line">    public String aDemo(@RequestBody Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">        return JSON.toJSONString(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/demo/b&quot;)</span><br><span class="line">    public String bDemo(Map&lt;String, Object&gt; map) &#123;</span><br><span class="line">        return JSON.toJSONString(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/demo/c&quot;)</span><br><span class="line">    public String cDemo(@RequestBody Demo demo) &#123;</span><br><span class="line">        return JSON.toJSONString(demo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/demo/d&quot;)</span><br><span class="line">    public String dDemo(Demo demo) &#123;</span><br><span class="line">        return JSON.toJSONString(demo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/demo/e&quot;)</span><br><span class="line">    public String eDemo(@RequestBody Long demo) &#123;</span><br><span class="line">        return JSON.toJSONString(demo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/demo/f&quot;)</span><br><span class="line">    public String fDemo(@RequestParam Long demo) &#123;</span><br><span class="line">        return JSON.toJSONString(demo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/demo/g&quot;)</span><br><span class="line">    public String gDemo(Long demo) &#123;</span><br><span class="line">        return JSON.toJSONString(demo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class Demo &#123;</span><br><span class="line">    private String demoName;</span><br><span class="line">    private Integer num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="给自己挖坑"><a href="#给自己挖坑" class="headerlink" title="给自己挖坑"></a>给自己挖坑</h5><p>下一篇是 AQS，力争写一篇看完就可以入门 AQS 源码的文章，并且让读者有冲动自己上手阅读。奥利给！！！<br>公众号一起交流：<br><img src="\uploads\headpic.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一篇公众号就讲个很简单的问题吧。前些天重构中前端传过来的参数突然就接受不到了。究其根本就是前端同学统一换了参数的提交格式，从 application/x-www-form-urlencoded 更换成 application/json。一句话解释本文就是 application/json 需要搭配 @RequestBody 使用。&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://kongdada.github.io/categories/Spring/"/>
    
    
      <category term="Java" scheme="https://kongdada.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://kongdada.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>在RedHat5.8上安装jira</title>
    <link href="https://kongdada.github.io/2018/12/12/jira/"/>
    <id>https://kongdada.github.io/2018/12/12/jira/</id>
    <published>2018-12-12T12:14:07.000Z</published>
    <updated>2020-01-13T03:42:26.992Z</updated>
    
    <content type="html"><![CDATA[<p>在某个抓耳挠腮写不出代码的傍晚，老大那个时常是灰色的头像开始疯狂跳动，正好处于转正前夕。我有点紧张了，点开了对话框。<br>“XX，下周你看一下JIRA，搭建个平台出来，如果需要Linux机器的话，找我要一下。”<br>“想了想，打了好几个字，然后删除，在对话框输入’好的‘，Enter”<br>言归正传，聊一下怎么搭建这个平台，分享一些我的低级失误，大家就不要再犯了，不要再折腾自己了，虽然我知道你还得折腾，谁让咱们都是不信命的程序员呢！<br><a id="more"></a></p><h4 id="确定你要安装的JIRA产品"><a href="#确定你要安装的JIRA产品" class="headerlink" title="确定你要安装的JIRA产品"></a>确定你要安装的JIRA产品</h4><p>你需要知道的事情是JIRA现在指的是一个产品组了，不是指某个具体的产品，具体如下图：<br><img src="https://ws1.sinaimg.cn/large/005Owz0qly1fy4xqq55pjj30hj0gcjsl.jpg" alt><br>啥也不多说了，我们要的就是JIRA Software</p><h4 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h4><p>官方推荐：</p><ul><li>jdk1.8</li><li>Mysql 5.5 5.6</li></ul><p>本次搭建中我使用的：</p><ul><li><p>RedHat5.8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@djt_36_149 ~]# lsb_release -a</span><br><span class="line">LSB Version:    :core-4.0-amd64:core-4.0-ia32:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0-ia32:graphics-4.0-noarch:printing-4.0-amd64:printing-4.0-ia32:printing-4.0-noarch</span><br><span class="line">Distributor ID: RedHatEnterpriseServer</span><br><span class="line">Description:    Red Hat Enterprise Linux Server release 5.8 (Tikanga)</span><br><span class="line">Release:        5.8</span><br><span class="line">Codename:       Tikanga</span><br></pre></td></tr></table></figure></li><li><p>jdk1.8.0_191</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@djt_36_149 ~]# java -version</span><br><span class="line">java version &quot;1.8.0_191&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_191-b12)</span><br><span class="line">Java HotSpot(TM) Server VM (build 25.191-b12, mixed mode)</span><br></pre></td></tr></table></figure></li><li><p>Mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@djt_36_149 jiraPackage]# rpm -qa | grep -i mysql</span><br><span class="line">MySQL-client-5.6.23-1.rhel5</span><br><span class="line">MySQL-server-5.6.23-1.rhel5</span><br></pre></td></tr></table></figure></li><li><p>JIRA Software<br>atlassian-jira-software-7.3.8-x64.bin</p></li></ul><h4 id="安装包提供"><a href="#安装包提供" class="headerlink" title="安装包提供"></a>安装包提供</h4><p><a href="https://pan.baidu.com/s/1-gT1s93KZfgO59U1mdfYPw" target="_blank" rel="noopener">https://pan.baidu.com/s/1-gT1s93KZfgO59U1mdfYPw 提取码: 8h3c</a></p><h4 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a>Mysql安装</h4><p>MySQL的安装推荐一篇文章：<br><a href="https://www.cnblogs.com/rusking/p/4422986.html" target="_blank" rel="noopener">https://www.cnblogs.com/rusking/p/4422986.html</a><br>按照上面文章做没有问题；亲测<br>但大致记录一下我安装时的一些细节：</p><h5 id="检查老版本并卸载"><a href="#检查老版本并卸载" class="headerlink" title="检查老版本并卸载"></a>检查老版本并卸载</h5><ul><li><p>看看Linux机器有没有Mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel204 /]# rpm -qa | grep -i mysql</span><br><span class="line">MySQL-server-advanced-5.6.23-1.rhel5</span><br><span class="line">MySQL-client-advanced-5.6.23-1.rhel5</span><br></pre></td></tr></table></figure></li><li><p>假设有，如上，则卸载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel204 /]# rpm -ev MySQL-server-advanced-5.6.23-1.rhel5 MySQL-client-advanced-5.6.23-1.rhel5</span><br></pre></td></tr></table></figure></li><li><p>删除残余文件<br>其实并不是所有含有mysql的文件都要删，把下面列出来的这几个删除就可以了；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel201 mysql]# find / -name mysql* 找到所有的mysql目录，并删除。 </span><br><span class="line">rm -rf /usr/share/mysql</span><br><span class="line">rm -rf /var/lib/mysql</span><br><span class="line">rm -rf /usr/lib64/mysql</span><br><span class="line">rm -rf /var/lib/mysql</span><br><span class="line">rm -rf /etc/my.cnf.d</span><br></pre></td></tr></table></figure></li></ul><h5 id="安装MySQL并创建需要的数据库"><a href="#安装MySQL并创建需要的数据库" class="headerlink" title="安装MySQL并创建需要的数据库"></a>安装MySQL并创建需要的数据库</h5><ul><li>服务端和客户端都需要<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel204 MySQL 5.6.23-RMP]# rpm -ivh MySQL-server-advanced-5.6.23-1.rhel5.x86_64.rpm </span><br><span class="line">Preparing... ########################################### [100%]</span><br><span class="line">1:MySQL-server-advanced ########################################### [100%]</span><br><span class="line">warning: user mysql does not exist - using root</span><br><span class="line">warning: group mysql does not exist - using root</span><br><span class="line">[root@rhel204 MySQL 5.6.23-RMP for oraclelinux or rhel5-x86-64V74393-01]# rpm -ivh MySQL-client-advanced-5.6.23-1.rhel5.x86_64.rpm </span><br><span class="line">Preparing... ########################################### [100%]</span><br><span class="line">1:MySQL-client-advanced ########################################### [100%]</span><br></pre></td></tr></table></figure></li></ul><p>安装完成有个提示：<br>You will find that password in ‘/root/.mysql_secret’<br>这个目录中有第一次登录需要的密码；要记一下。</p><ul><li>启动MySQL<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel204 MySQL 5.6.23-RMP]# /etc/init.d/mysql start</span><br><span class="line">Starting MySQL........[ OK ]</span><br><span class="line">[root@rhel204 MySQL 5.6.23-RMP]# /etc/init.d/mysql status</span><br><span class="line">MySQL running (13003)[ OK ]</span><br></pre></td></tr></table></figure></li></ul><h5 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h5><ul><li>登录<br>mysql -u root -p 粘贴前文中那个目录下的初始密码；</li><li>设置密码<br>mysqladmin -uroot -p旧密码 password 新密码<br>最好手动输入不要粘贴，有些不能识别；</li></ul><h5 id="创建创建数据库jira并为其赋权"><a href="#创建创建数据库jira并为其赋权" class="headerlink" title="创建创建数据库jira并为其赋权"></a>创建创建数据库jira并为其赋权</h5><ul><li><p>创建用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create user &apos;jira&apos;@&apos;%&apos; identified by &apos;123456&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li><li><p>创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create databases jiradb character set utf8 collate utf8_bin;</span><br></pre></td></tr></table></figure></li><li><p>为用户在这个数据库上赋予所有权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on  jiradb.* to jira@&apos;%&apos; identified  by &apos;123456&apos;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li></ul><p>至此数据库准备完成。<br>数据库这一块，如果操作没有得到预期的结果，就查询你自己的具体问题吧；</p><h4 id="JDK安装预配置"><a href="#JDK安装预配置" class="headerlink" title="JDK安装预配置"></a>JDK安装预配置</h4><p>这一点就不在介绍了，网上实在太多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_191</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure></p><h4 id="JIRA-Software-安装配置"><a href="#JIRA-Software-安装配置" class="headerlink" title="JIRA Software 安装配置"></a>JIRA Software 安装配置</h4><ul><li>这个请按照烂泥先生的流程来做，大佬还提供比较新的版本的破解:<br><a href="https://www.ilanni.com/?p=12119" target="_blank" rel="noopener">https://www.ilanni.com/?p=12119</a></li><li>如果不顺利也可以在参考另一篇：<br><a href="http://www.yfshare.vip/2017/05/09/%E9%83%A8%E7%BD%B2JIRA-7-2-2-for-Linux/" target="_blank" rel="noopener">http://www.yfshare.vip/2017/05/09/%E9%83%A8%E7%BD%B2JIRA-7-2-2-for-Linux/</a></li></ul><h4 id="JIRA使用参考"><a href="#JIRA使用参考" class="headerlink" title="JIRA使用参考"></a>JIRA使用参考</h4><p><a href="https://www.jianshu.com/p/145b5c33f7d0" target="_blank" rel="noopener">https://www.jianshu.com/p/145b5c33f7d0</a><br><a href="https://www.jianshu.com/p/975385878cde" target="_blank" rel="noopener">https://www.jianshu.com/p/975385878cde</a><br><a href="http://www.confluence.cn/pages/viewpage.action?pageId=1671211" target="_blank" rel="noopener">http://www.confluence.cn/pages/viewpage.action?pageId=1671211</a></p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>想来也是惭愧从接到任务到完成这个部署以及写完这个文章整整两天半花了出去；<br>起初在RedHat5.8上安装Mysql5.6，个人感觉是真是老牛拉新车；<br>厌烦，所以打算在本地mac上搭建一下，但我的Mysql数据库是8.0.11，能连接成功(补充一句，mysql-connect的jar包请使用5.1.44),但是在部署JIRA时，初始化有问题，官方不支持；<br>转去RedHat5.8，好不容易弄好了数据库却又安装了一个 JIRA core ,这玩意又少功能；删除，重来。<br>终于成功：放个图高兴一些；<br><img src="https://ws1.sinaimg.cn/large/005Owz0qly1fy54nbagc0j318c0l8di0.jpg" alt></p><h6 id="文章如有错误，欢迎指正"><a href="#文章如有错误，欢迎指正" class="headerlink" title="文章如有错误，欢迎指正"></a>文章如有错误，欢迎指正</h6>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某个抓耳挠腮写不出代码的傍晚，老大那个时常是灰色的头像开始疯狂跳动，正好处于转正前夕。我有点紧张了，点开了对话框。&lt;br&gt;“XX，下周你看一下JIRA，搭建个平台出来，如果需要Linux机器的话，找我要一下。”&lt;br&gt;“想了想，打了好几个字，然后删除，在对话框输入’好的‘，Enter”&lt;br&gt;言归正传，聊一下怎么搭建这个平台，分享一些我的低级失误，大家就不要再犯了，不要再折腾自己了，虽然我知道你还得折腾，谁让咱们都是不信命的程序员呢！&lt;br&gt;
    
    </summary>
    
      <category term="JIRA" scheme="https://kongdada.github.io/categories/JIRA/"/>
    
    
      <category term="Mysql" scheme="https://kongdada.github.io/tags/Mysql/"/>
    
      <category term="Jira" scheme="https://kongdada.github.io/tags/Jira/"/>
    
      <category term="Jdk" scheme="https://kongdada.github.io/tags/Jdk/"/>
    
  </entry>
  
  <entry>
    <title>在Spring中创建切面，使用AspectJ</title>
    <link href="https://kongdada.github.io/2018/11/19/aopAspectJ/"/>
    <id>https://kongdada.github.io/2018/11/19/aopAspectJ/</id>
    <published>2018-11-19T07:45:47.000Z</published>
    <updated>2020-01-13T03:42:26.989Z</updated>
    
    <content type="html"><![CDATA[<p>看了网上一些AspectJ的例子，大多一塌糊涂。说完这句话有点慌张，如果后续在学习中发现是我错了，再来打脸也不迟。<br>说说我的理解，目前我所学习到的实现AOP(切面)的方式大致可以分为两类，SpringAOP与AspectJ.关于SpringAOP的实现前两篇文章已经写过小例子了，欢迎查看。这篇用AspectJ实现AOP的小例子。代码配置都很细节，新手记录文。<br><a id="more"></a></p><h4 id="定义一个表演方法"><a href="#定义一个表演方法" class="headerlink" title="定义一个表演方法"></a>定义一个表演方法</h4><ul><li><p>定义接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package aopAspectJ;</span><br><span class="line"></span><br><span class="line">public interface Performance &#123;</span><br><span class="line">    String perform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现具体方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package aopAspectJ;</span><br><span class="line"></span><br><span class="line">public class PerformanceImpl implements Performance &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String perform() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;演出～～～&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(&quot;嗒嗒嗒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="定义一个切面，实现各种通知"><a href="#定义一个切面，实现各种通知" class="headerlink" title="定义一个切面，实现各种通知"></a>定义一个切面，实现各种通知</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package aopAspectJ;</span><br><span class="line"></span><br><span class="line">public aspect Audience &#123;</span><br><span class="line"></span><br><span class="line">    pointcut perFormance(): execution(* aopAspectJ.Performance.perform(..));</span><br><span class="line"></span><br><span class="line">    before(): perFormance()&#123;</span><br><span class="line">        System.out.println(&quot;表演前：手机静音！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    before(): perFormance()&#123;</span><br><span class="line">        System.out.println(&quot;表演前：请坐！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    after(): perFormance()&#123;</span><br><span class="line">        System.out.println(&quot;表演后：鼓掌！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    after()returning(String str): perFormance()&#123;</span><br><span class="line">        System.out.println(&quot;调用成功，表演很精彩，鼓掌！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    after()throwing(Exception e): perFormance()&#123;</span><br><span class="line">        System.out.println(&quot;调用失败，表演失败，退票！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需要一些特殊的配置"><a href="#需要一些特殊的配置" class="headerlink" title="需要一些特殊的配置"></a>需要一些特殊的配置</h4><h5 id="运行时的上下文-SpringAopAspectJ-xml"><a href="#运行时的上下文-SpringAopAspectJ-xml" class="headerlink" title="运行时的上下文:SpringAopAspectJ.xml"></a>运行时的上下文:SpringAopAspectJ.xml</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;performance&quot; class=&quot;aopAspectJ.PerformanceImpl&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h5 id="pom-xml要添加的依赖"><a href="#pom-xml要添加的依赖" class="headerlink" title="pom.xml要添加的依赖"></a>pom.xml要添加的依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--learnAOP--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--AspectJ--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.8.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.8.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="设置IDEA的编译方式"><a href="#设置IDEA的编译方式" class="headerlink" title="设置IDEA的编译方式"></a>设置IDEA的编译方式</h5><ul><li>将编译方式修改为Ajc</li><li>在你的本地仓库中找到aspectjtools-1.8.6.jar这个包，路径配置：Path to Ajc compiler<br><img src="https://ws1.sinaimg.cn/large/005Owz0qly1fxqbhirzalj30yj0my0w2.jpg" alt></li></ul><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ul><li><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package aopAspectJ;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &quot;classpath:SpringAopAspectJ.xml&quot;)</span><br><span class="line">public class PerformanceImplTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Performance performance;</span><br><span class="line">    @Test</span><br><span class="line">    public void perform() &#123;</span><br><span class="line">        performance.perform();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表演前：手机静音！</span><br><span class="line">表演前：请坐！</span><br><span class="line">演出～～～</span><br><span class="line">表演后：鼓掌！！！</span><br><span class="line">调用成功，表演很精彩，鼓掌！！！</span><br></pre></td></tr></table></figure></li></ul><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><h5 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h5><p>关于AOP的小例子写了三个，关于切面，切点，通知的定义，这个网上已经很多了不赘述。希望通过三个小例子，可以为你理清一点头绪，确定一下几点：</p><ul><li>AOP的实现分两大类SpringAOP和AspectJ;</li><li>SpringAOP的代码实现可以使用注解方式，也可以使用配置XML的方式；</li><li>注解与XML方式，其实可以理解成利用不同的写法把这个特定的方法和这些通知组织起来，联系起来。</li></ul><h5 id="看过的好文章"><a href="#看过的好文章" class="headerlink" title="看过的好文章"></a>看过的好文章</h5><p>最后一部分提供两篇我看过的，很好的文章，希望对你也有所启迪。</p><ul><li>AOP1<br><a href="https://www.jianshu.com/p/fe8d1e8bd63e" target="_blank" rel="noopener">这篇很简明的说明了SpringAOP与AspectJ的区别</a></li><li>AOP2<br><a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">这是一篇从AOP起源讲到不同实现的文章，几乎覆盖了我这篇，但我这是个完整例子。</a></li></ul><h5 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h5><ul><li>整个工程代码在下面的链接中，如果需要可以下载看一看。</li><li><a href="https://github.com/kongdada/learnSpring" target="_blank" rel="noopener">点击跳转到我的GitHub</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了网上一些AspectJ的例子，大多一塌糊涂。说完这句话有点慌张，如果后续在学习中发现是我错了，再来打脸也不迟。&lt;br&gt;说说我的理解，目前我所学习到的实现AOP(切面)的方式大致可以分为两类，SpringAOP与AspectJ.关于SpringAOP的实现前两篇文章已经写过小例子了，欢迎查看。这篇用AspectJ实现AOP的小例子。代码配置都很细节，新手记录文。&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://kongdada.github.io/categories/Spring/"/>
    
    
      <category term="Java" scheme="https://kongdada.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://kongdada.github.io/tags/Spring/"/>
    
      <category term="AspectJ" scheme="https://kongdada.github.io/tags/AspectJ/"/>
    
  </entry>
  
  <entry>
    <title>在Spring中创建切面，通过切面引入新功能-使用配置XML</title>
    <link href="https://kongdada.github.io/2018/11/14/aopXML/"/>
    <id>https://kongdada.github.io/2018/11/14/aopXML/</id>
    <published>2018-11-14T02:58:37.000Z</published>
    <updated>2020-01-13T03:42:26.990Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博客中记录了使用Java注解方式开发一个切面的小例子，这一篇记录使用XML配置的方式开发一个切面的例子，同时也完成通过配置XML新增功能。<br><a id="more"></a></p><h4 id="实现切面"><a href="#实现切面" class="headerlink" title="实现切面"></a>实现切面</h4><h5 id="定义特定的方法"><a href="#定义特定的方法" class="headerlink" title="定义特定的方法"></a>定义特定的方法</h5><ul><li><p>首先定一个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package aopXML;</span><br><span class="line"></span><br><span class="line">public interface Performance &#123;</span><br><span class="line">    void perform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现这个接口，定义一个叫演出的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package aopXML;</span><br><span class="line"></span><br><span class="line">public class PerformanceImpl implements Performance &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void perform() &#123;</span><br><span class="line">        System.out.println(&quot;演出～～～&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="定义一个切面"><a href="#定义一个切面" class="headerlink" title="定义一个切面"></a>定义一个切面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package aopXML;</span><br><span class="line"></span><br><span class="line">public class Audience &#123;</span><br><span class="line">    public void silencePhone() &#123;</span><br><span class="line">        System.out.println(&quot;手机静音！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void takeSeats() &#123;</span><br><span class="line">        System.out.println(&quot;请坐！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void applause() &#123;</span><br><span class="line">        System.out.println(&quot;表演结束，鼓掌！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void demanRefund() &#123;</span><br><span class="line">        System.out.println(&quot;表演失败，退票！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="将切面跟特定方法联系起来"><a href="#将切面跟特定方法联系起来" class="headerlink" title="将切面跟特定方法联系起来"></a>将切面跟特定方法联系起来</h5><p>这一次采用配置XML的方式来开发；这个文件叫SpringAOP.xml<br>定义切点，其实就是指定那个特定方法<br>定义通知，其实就是通知对应的方法在特定方法前还是后调用，或者是特定方法调用成功或者出现异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;audience&quot; class=&quot;aopXML.Audience&quot; /&gt;</span><br><span class="line">    &lt;bean id=&quot;Performance&quot; class=&quot;aopXML.PerformanceImpl&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!-- 这是定义一个切面，切面是切点和通知的集合--&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;do&quot; ref=&quot;audience&quot;&gt;</span><br><span class="line">            &lt;!-- 定义切点 ，后面是expression语言，表示包括该接口中定义的所有方法都会被执行--&gt;</span><br><span class="line">            &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* aopXML.Performance.perform(..)))&quot; /&gt;</span><br><span class="line">            &lt;!-- 定义通知 --&gt;</span><br><span class="line">            &lt;aop:before method=&quot;silencePhone&quot; pointcut-ref=&quot;point&quot; /&gt;</span><br><span class="line">            &lt;aop:before method=&quot;takeSeats&quot; pointcut-ref=&quot;point&quot; /&gt;</span><br><span class="line">            &lt;aop:after-returning method=&quot;applause&quot; pointcut-ref=&quot;point&quot; /&gt;</span><br><span class="line">            &lt;aop:after-throwing method=&quot;demanRefund&quot; pointcut-ref=&quot;point&quot; /&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><h5 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package aopXML;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &quot;classpath:SpringAOP.xml&quot;)</span><br><span class="line">public class PerformanceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Performance performance;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        performance.perform();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">手机静音！</span><br><span class="line">请坐！</span><br><span class="line">演出～～～</span><br><span class="line">表演结束，鼓掌！！！</span><br></pre></td></tr></table></figure></p><h4 id="新加功能"><a href="#新加功能" class="headerlink" title="新加功能"></a>新加功能</h4><h5 id="定义新加功能"><a href="#定义新加功能" class="headerlink" title="定义新加功能"></a>定义新加功能</h5><ul><li><p>定义功能接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package aopXML;</span><br><span class="line"></span><br><span class="line">public interface Encoreable &#123;</span><br><span class="line">    void performEncore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package aopXML;</span><br><span class="line"></span><br><span class="line">public class EncoreableImpl implements Encoreable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void performEncore() &#123;</span><br><span class="line">        System.out.println(&quot;返场表演～～～&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="将新加的功能与特定方法联系起来"><a href="#将新加的功能与特定方法联系起来" class="headerlink" title="将新加的功能与特定方法联系起来"></a>将新加的功能与特定方法联系起来</h5><p>修改SpringAOP.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;audience&quot; class=&quot;aopXML.Audience&quot; /&gt;</span><br><span class="line">    &lt;bean id=&quot;Performance&quot; class=&quot;aopXML.PerformanceImpl&quot; /&gt;</span><br><span class="line">    &lt;bean id=&quot;Encoreable&quot; class=&quot;aopXML.EncoreableImpl&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!-- 这是定义一个切面，切面是切点和通知的集合--&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;do&quot; ref=&quot;audience&quot;&gt;</span><br><span class="line">            &lt;!-- 定义切点 ，后面是expression语言，表示包括该接口中定义的所有方法都会被执行--&gt;</span><br><span class="line">            &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* aopXML.Performance.perform(..)))&quot; /&gt;</span><br><span class="line">            &lt;!-- 定义通知 --&gt;</span><br><span class="line">            &lt;aop:before method=&quot;silencePhone&quot; pointcut-ref=&quot;point&quot; /&gt;</span><br><span class="line">            &lt;aop:before method=&quot;takeSeats&quot; pointcut-ref=&quot;point&quot; /&gt;</span><br><span class="line">            &lt;aop:after-returning method=&quot;applause&quot; pointcut-ref=&quot;point&quot; /&gt;</span><br><span class="line">            &lt;aop:after-throwing method=&quot;demanRefund&quot; pointcut-ref=&quot;point&quot; /&gt;</span><br><span class="line">            &lt;aop:declare-parents types-matching=&quot;aopXML.Performance+&quot; implement-interface=&quot;aopXML.Encoreable&quot; default-impl=&quot;aopXML.EncoreableImpl&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><ul><li>aop:declare-parents 使用这个标签将新加功能与特定方法联系在一起；</li><li>types-matching=”aopXML.Performance+” 为所有实现Performance接口的类的父类增加新功能；</li><li>implement-interface 新加功能对应着的接口；</li><li>default-impl 新加功能接口的实现；</li></ul><h5 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package aopXML;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &quot;classpath:SpringAOP.xml&quot;)</span><br><span class="line">public class PerformanceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Performance performance;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        performance.perform();</span><br><span class="line">        System.out.println(&quot;+++++++++++++++++++++++++++++++++++&quot;);</span><br><span class="line">        Encoreable encoreable = (Encoreable)performance;</span><br><span class="line">        encoreable.performEncore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">手机静音！</span><br><span class="line">请坐！</span><br><span class="line">演出～～～</span><br><span class="line">表演结束，鼓掌！！！</span><br><span class="line">+++++++++++++++++++++++++++++++++++</span><br><span class="line">返场表演～～～</span><br></pre></td></tr></table></figure></p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><ul><li>整个工程代码在下面的链接中，如果需要可以下载看一看。</li><li><a href="https://github.com/kongdada/learnSpring" target="_blank" rel="noopener">点击跳转到我的GitHub</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博客中记录了使用Java注解方式开发一个切面的小例子，这一篇记录使用XML配置的方式开发一个切面的例子，同时也完成通过配置XML新增功能。&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://kongdada.github.io/categories/Spring/"/>
    
    
      <category term="Java" scheme="https://kongdada.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://kongdada.github.io/tags/Spring/"/>
    
      <category term="XML" scheme="https://kongdada.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>在Spring中创建切面，通过切面引入新功能-使用JAVA注解方式</title>
    <link href="https://kongdada.github.io/2018/11/13/aopJavaConfig/"/>
    <id>https://kongdada.github.io/2018/11/13/aopJavaConfig/</id>
    <published>2018-11-13T08:34:21.000Z</published>
    <updated>2020-01-13T03:42:26.990Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看《Spring实战》，在这儿使用注解完整的实现一个切面的例子，也实现通过注解引入新功能；<br><a id="more"></a></p><h4 id="实现切面"><a href="#实现切面" class="headerlink" title="实现切面"></a>实现切面</h4><p>关于切面相关概念这篇不提，可以大致理解成，只要调用某个特定的方法，这个调用信息会被切面拦截，然后执行切面定义的逻辑，之后才能顺利的调用该方法。<br>我这个是一个maven项目所有代码写在同一个包下面，测试类除外。关于切面这个部分可能需要导入一些包。<br>pom.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h5 id="定义特定的方法"><a href="#定义特定的方法" class="headerlink" title="定义特定的方法"></a>定义特定的方法</h5><ul><li><p>首先定一个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package aopJavaConfig;</span><br><span class="line"></span><br><span class="line">public interface Performance &#123;</span><br><span class="line">    public void perform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现这个接口，定义一个叫演出的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package aopJavaConfig;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class PerformanceImpl implements Performance &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void perform()&#123;</span><br><span class="line">        System.out.println(&quot;演出～～～&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="定义一个切面，同时定义了切点和通知"><a href="#定义一个切面，同时定义了切点和通知" class="headerlink" title="定义一个切面，同时定义了切点和通知"></a>定义一个切面，同时定义了切点和通知</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package aopJavaConfig;</span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class Audience &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(* aopJavaConfig.Performance.perform(..))&quot;)</span><br><span class="line">    public void performance()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;performance()&quot;)</span><br><span class="line">     public void silencePhone()&#123;</span><br><span class="line">        System.out.println(&quot;手机静音！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;performance()&quot;)</span><br><span class="line">    public void takeSeats()&#123;</span><br><span class="line">        System.out.println(&quot;请坐！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterReturning(&quot;performance()&quot;)</span><br><span class="line">    public void applause()&#123;</span><br><span class="line">        System.out.println(&quot;表演结束，鼓掌！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterThrowing(&quot;performance()&quot;)</span><br><span class="line">    public void demanRefund()&#123;</span><br><span class="line">        System.out.println(&quot;表演失败，退票！！！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@Aspect修饰的这个类是切面，我们可以在切面中定义切点和通知；</li><li>@Pointcut修饰的是切点，可以看到切点就是我们之前定义的那个特定的方法；</li><li>@Before修饰的方法会在定义的特定方法之前被调用；</li><li>@AfterReturning修饰的方法会在特定方法被成功调用后执行；</li><li>@AfterThrowing修饰的方法会在特定方法执行异常时被执行；</li></ul><h5 id="定义一个配置类"><a href="#定义一个配置类" class="headerlink" title="定义一个配置类"></a>定义一个配置类</h5><p>这个配置类负责开启自动代理，并且将我们定义好的切面声明成Bean；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package aopJavaConfig;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">@ComponentScan</span><br><span class="line">public class ConcertConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Audience audience()&#123;</span><br><span class="line">        return new Audience();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们有两个bean，一个是那个特定的方法，一个是声明好的切面，那么我们就有一个很朴素的冲动，这样定义是否成功了呢，所以写一个测试类；</p><h5 id="测试切面定义是否成功"><a href="#测试切面定义是否成功" class="headerlink" title="测试切面定义是否成功"></a>测试切面定义是否成功</h5><p>预期的结果：调用演出方法，在控制台打印出来演出之前要干嘛，演出成功后要干嘛；<br>具体的输出请查看代码本身；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package aopJavaConfig;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = ConcertConfig.class)</span><br><span class="line">public class PerformanceTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Performance performance;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        performance.perform();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，使用java注解方式定义一个切面结束；</p><h4 id="引入新功能（DeclareParents）"><a href="#引入新功能（DeclareParents）" class="headerlink" title="引入新功能（DeclareParents）"></a>引入新功能（DeclareParents）</h4><p>接上文代码，当我们接受老代码，期望在原来的特定方法的基础上加一个功能，很朴素的想法就是修改原来的方法，加一段功能代码，但是假设现在老代码很复杂不得修改；那么为了增加这个功能，Spring提供了一个另一个实现方式。</p><h5 id="新功能代码"><a href="#新功能代码" class="headerlink" title="新功能代码"></a>新功能代码</h5><ul><li><p>定义新接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package aopJavaConfig;</span><br><span class="line"></span><br><span class="line">public interface Encoreable &#123;</span><br><span class="line">    void performEncore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现这个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package aopJavaConfig;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class EncoreableImpl implements Encoreable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void performEncore()&#123;</span><br><span class="line">        System.out.println(&quot;返场表演～～～&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="将新功能引入原来特定方法形成的bean中"><a href="#将新功能引入原来特定方法形成的bean中" class="headerlink" title="将新功能引入原来特定方法形成的bean中"></a>将新功能引入原来特定方法形成的bean中</h5><p>可以将bean看作一个对象，这个特定的这个对象中添加一个新的方法，也就是让这个对象可以直接调用新加的方法；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package aopJavaConfig;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.DeclareParents;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">public class EncoreableIntroducer &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 此注解可以将新加的接口引入到原来调用目标函数的bean中</span><br><span class="line">     */</span><br><span class="line">    @DeclareParents(value = &quot;aopJavaConfig.Performance+&quot;, defaultImpl = EncoreableImpl.class)</span><br><span class="line">    public static Encoreable encoreable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>@DeclareParents 这个注解的value制定了这个新方法加给谁，defaultImpl这个参数指定了新加方法的具体实现。<br>实际上新加方法是加给了value制定方法的父类。<h5 id="新加方法要告知Spring容器"><a href="#新加方法要告知Spring容器" class="headerlink" title="新加方法要告知Spring容器"></a>新加方法要告知Spring容器</h5>修改配置类如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package aopJavaConfig;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">@ComponentScan</span><br><span class="line">public class ConcertConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Audience audience()&#123;</span><br><span class="line">        return new Audience();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public EncoreableIntroducer encoreableIntroducer()&#123;</span><br><span class="line">        return new EncoreableIntroducer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><p>预期结果：能够使用特定类的对象成功调用新加的方法；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package aopJavaConfig;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = ConcertConfig.class)</span><br><span class="line">public class PerformanceTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Performance performance;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        performance.perform();</span><br><span class="line">        System.out.println(&quot;+++++++++++++++++++++++++++++++++++&quot;);</span><br><span class="line">        Encoreable encoreable = (Encoreable)performance;</span><br><span class="line">        encoreable.performEncore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">手机静音！</span><br><span class="line">请坐！</span><br><span class="line">演出～～～</span><br><span class="line">表演结束，鼓掌！！！</span><br><span class="line">+++++++++++++++++++++++++++++++++++</span><br><span class="line">返场表演～～～</span><br></pre></td></tr></table></figure></p><p>至此使用注解方式开发切面，切点，通知，新加方法都已经完成。代码经过了验证；<br>如有错误，还请指正。欢迎交流。</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><ul><li>整个工程代码在下面的链接中，如果需要可以下载看一看。</li><li><a href="https://github.com/kongdada/learnSpring" target="_blank" rel="noopener">点击跳转到我的GitHub</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看《Spring实战》，在这儿使用注解完整的实现一个切面的例子，也实现通过注解引入新功能；&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://kongdada.github.io/categories/Spring/"/>
    
    
      <category term="Java" scheme="https://kongdada.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://kongdada.github.io/tags/Spring/"/>
    
      <category term="注解" scheme="https://kongdada.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>shell中嵌入SQL查询</title>
    <link href="https://kongdada.github.io/2018/08/29/shellPit01/"/>
    <id>https://kongdada.github.io/2018/08/29/shellPit01/</id>
    <published>2018-08-29T02:08:48.000Z</published>
    <updated>2020-01-13T03:42:26.995Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在做一个hadoop升级的事情。分配到我的任务就是在新的集群测试项目中的脚本，保证能够在新集群跑得通，并产生正确的数据。那么数据正不正确怎么个比较法呢，因为暂时是新旧集群一起运行此项目，项目最后产出的数据量也不大，十万过一点，四五个文件。干脆down下来用beyond Compare这个软件比较一下算了。但在down下来的过程中踩坑了。<br><a id="more"></a></p><h4 id="问题复述"><a href="#问题复述" class="headerlink" title="问题复述"></a>问题复述</h4><p>因为种种限制，我不能直接将两个数据库中的数据导出来做比较，但是任何查询都是可以的，那么最简单的想法就是写个脚本，根据不同的传参，配置不同的数据库信息，导出数据。<br>脚本中最重要的就是怎么把SQL嵌入脚本。说来简单，我是这样写的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql=&quot;select * from test.info;&quot;</span><br><span class="line">mysql=&quot;mysql -h$HOST -p$PORT -u$USER -p$PASSWD&quot;</span><br><span class="line">echo $&#123;sql&#125; | $&#123;mysql&#125;</span><br></pre></td></tr></table></figure></p><p>第一行查询语句；第二行数据库登录信息，ip地址，用户，密码；第三行使用登录信息进行这个sql查询。<br>执行报错，根据报错看出来是语法问题，select 附近有错。<br>在第三行<code>echo ${sql}</code>，发现这个<code>select</code>后面的<code>*</code>，居然被替换成了当前脚本所在目录下的所有文件名字。怎么个意思呢？<br>假设<code>/user/local</code>下有<code>a.txt b.txt c.sh</code>三个文件，你在<code>c.sh</code>中写了如上（就那个select <code>*</code> ）的代码，那么你的查询语句中的<code>*</code>就会被替换成<code>a.txt b.txt</code>;</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>将<code>echo ${sql} | ${mysql}</code>改为<code>echo &quot;${sql}&quot; | ${mysql}</code><br>没看错就是在变量<code>${sql}</code>外面包了一层双引号，就这么解决了。</p><h4 id="脑洞大开"><a href="#脑洞大开" class="headerlink" title="脑洞大开"></a>脑洞大开</h4><p>由于没有查到翔实的资料，以下都是个人猜测。<br>将脚本写成下面这个样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> #!/bin/bash</span><br><span class="line">sql=&quot;select * from test.klhinfo;&quot;</span><br><span class="line">mysql=&quot;mysql  -uroot -pmysql123&quot;</span><br><span class="line">echo $&#123;sql&#125;</span><br><span class="line">echo &quot;$&#123;sql&#125;&quot; | $&#123;mysql&#125;</span><br></pre></td></tr></table></figure></p><p>然后运行一下，发现当<code>echo ${sql}</code>时，其中的星号被替换成了当前目录下的文件名。<br>脑洞大开：<code>${sql}</code> 被替换成 <code>$select $* $from $test.klhinfo</code>, <code>$*</code>正好是获取所有传入的参数，估计是将当前目录下的文件名都当作参数传进来了。</p><h4 id="在shell脚本中嵌入SQL的姿势"><a href="#在shell脚本中嵌入SQL的姿势" class="headerlink" title="在shell脚本中嵌入SQL的姿势"></a>在shell脚本中嵌入SQL的姿势</h4><p>我所了解的暂时有三种方式，在生产环境中第二种方式使用最多，第一种也常见，第三种比较少见。</p><ul><li><p>shell中echo方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> #!/bin/bash</span><br><span class="line">sql=&quot;select * from test.klhinfo;&quot;</span><br><span class="line">mysql=&quot;mysql  -uroot -pmysql123&quot;</span><br><span class="line">echo &quot;$&#123;sql&#125;&quot;</span><br><span class="line">echo &quot;$&#123;sql&#125;&quot; | $&#123;mysql&#125;</span><br></pre></td></tr></table></figure></li><li><p>mysql命令行方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">sql=&quot;select * from test.klhinfo;&quot;</span><br><span class="line">mysql=&quot;mysql  -uroot -pmysql123&quot;</span><br><span class="line">echo &quot;$&#123;sql&#125;&quot;</span><br><span class="line">$&#123;mysql&#125; -N -e &quot;$&#123;sql&#125;&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用EOF直接嵌入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">passwd=&apos;mysql123&apos;</span><br><span class="line">mysql -u root -p$&#123;passwd&#125; &lt;&lt;EOF</span><br><span class="line">use kaka;</span><br><span class="line">select * from user;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天在做一个hadoop升级的事情。分配到我的任务就是在新的集群测试项目中的脚本，保证能够在新集群跑得通，并产生正确的数据。那么数据正不正确怎么个比较法呢，因为暂时是新旧集群一起运行此项目，项目最后产出的数据量也不大，十万过一点，四五个文件。干脆down下来用beyond Compare这个软件比较一下算了。但在down下来的过程中踩坑了。&lt;br&gt;
    
    </summary>
    
      <category term="shell" scheme="https://kongdada.github.io/categories/shell/"/>
    
    
      <category term="shell sql" scheme="https://kongdada.github.io/tags/shell-sql/"/>
    
  </entry>
  
  <entry>
    <title>mapreduce进程ruduce端内存溢出，解决方法和探索</title>
    <link href="https://kongdada.github.io/2018/08/16/PigOOM1/"/>
    <id>https://kongdada.github.io/2018/08/16/PigOOM1/</id>
    <published>2018-08-16T02:42:18.000Z</published>
    <updated>2020-01-13T03:42:26.985Z</updated>
    
    <content type="html"><![CDATA[<p>昨天碰到一个pig任务执行过程中发生了内存溢出。写点文字记录一下解决过程，顺便整理一下自己的思路。<br><a id="more"></a></p><h4 id="一-错误信息"><a href="#一-错误信息" class="headerlink" title="一 错误信息"></a>一 错误信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">2018-08-15 05:20:24,102 [main] INFO  org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MapReduceLauncher - 75% complete</span><br><span class="line">2018-08-15 05:20:58,720 [main] WARN  org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MapReduceLauncher - Ooops! Some job has failed! Specify -stop_on_failure if you want Pig to stop immediately on failure.</span><br><span class="line">2018-08-15 05:20:58,721 [main] INFO  org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MapReduceLauncher - job job_1534254968444_0056 has failed! Stop running all dependent jobs</span><br><span class="line">2018-08-15 05:20:58,721 [main] INFO  org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MapReduceLauncher - 100% complete</span><br><span class="line">2018-08-15 05:20:59,123 [main] ERROR org.apache.pig.tools.pigstats.SimplePigStats - ERROR 2997: Unable to recreate exception from backed error: AttemptID:attempt_1534254968444_0056_r_000000_3 Info:Error: org.apache.hadoop.mapreduce.task.reduce.Shuffle$ShuffleError: error in shuffle in fetcher#12</span><br><span class="line">at org.apache.hadoop.mapreduce.task.reduce.Shuffle.run(Shuffle.java:134)</span><br><span class="line">at org.apache.hadoop.mapred.ReduceTask.run(ReduceTask.java:376)</span><br><span class="line">at org.apache.hadoop.mapred.YarnChild$2.run(YarnChild.java:164)</span><br><span class="line">at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">at javax.security.auth.Subject.doAs(Subject.java:415)</span><br><span class="line">at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1917)</span><br><span class="line">at org.apache.hadoop.mapred.YarnChild.main(YarnChild.java:158)</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at org.apache.hadoop.io.BoundedByteArrayOutputStream.&lt;init&gt;(BoundedByteArrayOutputStream.java:56)</span><br><span class="line">at org.apache.hadoop.io.BoundedByteArrayOutputStream.&lt;init&gt;(BoundedByteArrayOutputStream.java:46)</span><br><span class="line">at org.apache.hadoop.mapreduce.task.reduce.InMemoryMapOutput.&lt;init&gt;(InMemoryMapOutput.java:63)</span><br><span class="line">at org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl.unconditionalReserve(MergeManagerImpl.java:309)</span><br><span class="line">at org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl.reserve(MergeManagerImpl.java:299)</span><br><span class="line">at org.apache.hadoop.mapreduce.task.reduce.Fetcher.copyMapOutput(Fetcher.java:539)</span><br><span class="line">at org.apache.hadoop.mapreduce.task.reduce.Fetcher.copyFromHost(Fetcher.java:348)</span><br><span class="line">at org.apache.hadoop.mapreduce.task.reduce.Fetcher.run(Fetcher.java:198)</span><br><span class="line"></span><br><span class="line">2018-08-15 05:20:59,123 [main] ERROR org.apache.pig.tools.pigstats.PigStatsUtil - 1 map reduce job(s) failed!</span><br><span class="line">2018-08-15 05:20:59,125 [main] INFO  org.apache.pig.tools.pigstats.SimplePigStats - Script Statistics:</span><br></pre></td></tr></table></figure><h4 id="二-解决方法"><a href="#二-解决方法" class="headerlink" title="二 解决方法"></a>二 解决方法</h4><p>看到<code>mapreduce.task.reduce.Shuffle$ShuffleError: error in shuffle in fetcher#12</code>和<code>Caused by: java.lang.OutOfMemoryError: Java heap space</code>；<br>就可以断定是在Reduce端的shuffer过程中内存不足，简单粗暴的做法就是加大MR过程中reduce端的内存。具体涉及到的参数如下：</p><ol><li><code>mapreduce.reduce.memory.mb</code> // 这个是为reduce端分配的内存大小，一般来说是1024的倍数。如果你分配了2000m，系统也会为你分配2048m.</li><li><code>mapreduce.reduce.java.opts</code> // 这个是指定reduce端的JVM参数，这个的大小一般是上一个参数的0.75倍，因为要剩一些内存给非JVM进程。<h5 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h5>因为在项目中是在一个shell脚本中用命令行调用了一个pig脚本。<br><code>$PIG_HOME/bin/pig -param YESTERDAY=$YESTERDAY -param FUNCTION=$FUNCTION/$TASK_PROGRAM_DIR/example.pig</code><br>那么就会产生一个问题，我们解决方法中提到的两个配置参数，插入那个脚本合适？<br>经过测试以上两个参数配置在shell脚本中是不起作用的。只能配置在pig脚本中。<br>pig中使用set语法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET mapreduce.reduce.memory.mb 3072;</span><br><span class="line">SET mapreduce.reduce.java.opts &apos;-Xms3000m -Xmx3000m&apos;;</span><br></pre></td></tr></table></figure></li></ol><p>具体配置参数的大小要结合上一次运行时内存分配的大小和数据量的大小，然后自己预估一个合适的值。不行就继续调整。直到问题解决。</p><h4 id="三-探讨"><a href="#三-探讨" class="headerlink" title="三 探讨"></a>三 探讨</h4><p>我们以上给出的方法是一种土财主的做法，基于我们有充足的内存。<br>再看报错信息<code>error in shuffle in fetcher#12</code>，发现是在下载map输出时内存不够了。<br>Reduce在shuffle阶段对下载来的map数据，并不是立刻就写入磁盘的，而是会先缓存在内存中，然后当使用内存达到一定量的时候才刷入磁盘。<br>那么就有可能是某个map输出过大，下载过来直接撑爆了内存。引入两个参数：</p><ol><li>参数: <code>mapred.job.shuffle.input.buffer.percent（default 0.7）</code><br>说明: 用来缓存shuffle数据的reduce task heap百分比<br>这个参数其实是一个百分比，意思是说，shuffile在reduce内存中的数据最多使用内存量为：0.7 × maxHeap of reduce task。<br>缓存的数据量超过了这个值，便开始将缓存数据写入磁盘。</li><li>参数：<code>mapred.job.shuffle.merge.percent（default 0.66）</code><br>说明:缓存的内存中多少百分比后开始做merge操作<br>假设<code>mapred.job.shuffle.input.buffer.percent</code>为0.7，reduce task的max heapsize为1G，那么用来做下载数据缓存的内存就为大概700MB左右，这700M的内存，也不是要等到全部写满才会往磁盘刷的，而是当这700M中被使用到了一定的限度（通常是一个百分比），就会开始往磁盘刷。<br>假设<code>mapred.job.shuffle.merge.percent（default 0.66）</code>为0.66，那么当下载过来的map的输出在缓存中达到 0.7 <em> maxHeap </em> 0.66这个值，缓存的数据就开始往磁盘中写。<br>个人理解这就是两个关卡，前者决定用内存的百分之多少来做数据缓存，后者决定缓存使用到多少就开始往磁盘写数据。</li></ol><h5 id="探讨结果"><a href="#探讨结果" class="headerlink" title="探讨结果"></a>探讨结果</h5><p>当我们机器本身的内存有限，或者我们追求内存的利用率。就可以放弃从整体上扩大内存的做法，转而调整任务各个阶段使用内存的比例。<br>在这次报错中我们就可以尝试将下面两个参数调小一点，<br><code>mapred.job.shuffle.input.buffer.percent</code> // 这个调小，是将reduce端用来做数据缓存的内存减少。防止下载一个过大的map输出直接撑爆内存，导致任务失败。<br><code>mapred.job.shuffle.merge.percent</code> // 这个调小是在上一个的基础上，进一步提前了将缓存的数据写入磁盘的时间。</p><p>如有错误，欢迎指出，十分感谢。<br>参考文章：<br><a href="https://blog.csdn.net/ruidongliu/article/details/11689459" target="_blank" rel="noopener">MapReduce优化—-参数的解释以及设置</a><br><a href="https://segmentfault.com/a/1190000003777237" target="_blank" rel="noopener">Yarn下Mapreduce的内存参数理解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天碰到一个pig任务执行过程中发生了内存溢出。写点文字记录一下解决过程，顺便整理一下自己的思路。&lt;br&gt;
    
    </summary>
    
      <category term="Hadoop" scheme="https://kongdada.github.io/categories/Hadoop/"/>
    
    
      <category term="pig" scheme="https://kongdada.github.io/tags/pig/"/>
    
      <category term="mapreduce" scheme="https://kongdada.github.io/tags/mapreduce/"/>
    
      <category term="OOM" scheme="https://kongdada.github.io/tags/OOM/"/>
    
  </entry>
  
  <entry>
    <title>Hbase ImportTSV</title>
    <link href="https://kongdada.github.io/2018/08/14/HbaseImportTSV/"/>
    <id>https://kongdada.github.io/2018/08/14/HbaseImportTSV/</id>
    <published>2018-08-14T07:16:46.000Z</published>
    <updated>2020-01-13T03:42:26.983Z</updated>
    
    <content type="html"><![CDATA[<p>这个也是最近经手的一个项目中涉及到的一个可以将HDFS上的数据直接导入HBASE表中的命令行工具。这个属于HBASE所以与上一篇Hadoop中的工具分开来写。<br><a id="more"></a></p><h4 id="Hbase-importTsv"><a href="#Hbase-importTsv" class="headerlink" title="Hbase importTsv"></a>Hbase importTsv</h4><h5 id="概述和使用步骤："><a href="#概述和使用步骤：" class="headerlink" title="概述和使用步骤："></a>概述和使用步骤：</h5><p>ImportTsv是Hbase提供的一个命令行工具，可以将存储在HDFS上的自定义分隔符（默认\t）的数据文件，通过一条命令方便的导入到HBase表中，对于大数据量导入非常实用，其中包含两种方式将数据导入到HBase表中：<br>stepA: 生成HFile格式的文件<br>stepB: 执行一个叫做CompleteBulkLoad的命令，将文件move到HBase表空间目录</p><h5 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a>一个例子：</h5><ul><li><p>第一步，生成Hfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ bin/hbase org.apache.hadoop.hbase.mapreduce.ImportTsv </span><br><span class="line">-Dimporttsv.columns=HBASE_ROW_KEY,f:accountID,f:time,f:crownCommonKeyID//格式</span><br><span class="line">-Dimporttsv.bulk.output=hdfs://storefile-outputdir //输出目录</span><br><span class="line">&lt;tablename&gt; //输出后保存文件名</span><br><span class="line">&lt;hdfs-data-inputdir&gt;//输入目录</span><br></pre></td></tr></table></figure></li><li><p>第二步，完成导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ bin/hbase org.apache.hadoop.hbase.mapreduce.LoadIncrementalHFiles </span><br><span class="line">&lt;hdfs://storefileoutput&gt; //这是上文的输出目录，也是这一步的输入目录</span><br><span class="line">&lt;tablename&gt;//导入hbase的表名</span><br></pre></td></tr></table></figure></li></ul><p>基本使用便是以上这样子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个也是最近经手的一个项目中涉及到的一个可以将HDFS上的数据直接导入HBASE表中的命令行工具。这个属于HBASE所以与上一篇Hadoop中的工具分开来写。&lt;br&gt;
    
    </summary>
    
      <category term="Hbase" scheme="https://kongdada.github.io/categories/Hbase/"/>
    
    
      <category term="Hbase" scheme="https://kongdada.github.io/tags/Hbase/"/>
    
      <category term="import" scheme="https://kongdada.github.io/tags/import/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop Streamig 和 Hadoop Distcp的简单介绍</title>
    <link href="https://kongdada.github.io/2018/08/14/StreamingAndDistcp/"/>
    <id>https://kongdada.github.io/2018/08/14/StreamingAndDistcp/</id>
    <published>2018-08-14T02:38:12.000Z</published>
    <updated>2020-01-13T03:42:26.988Z</updated>
    
    <content type="html"><![CDATA[<p>今天总结一下经手的一个项目中用到的Hadoop工具；<br>距离上一篇文章不知不觉快4个月过去了，期间经历了毕业，入职这些事儿。一直想写个求职总结，错过了当初那份激情，现在已经有点淡忘那种真真切切的朝不保夕的感受。看后来有没有心情在更吧。我毕设也挺好玩，挺简单的一个东西，有时间也可以写写。这都是后话。<br><a id="more"></a></p><h4 id="Hadoop-Streaming"><a href="#Hadoop-Streaming" class="headerlink" title="Hadoop Streaming"></a>Hadoop Streaming</h4><h5 id="概述与基本使用："><a href="#概述与基本使用：" class="headerlink" title="概述与基本使用："></a>概述与基本使用：</h5><p>Hadoop streaming是Hadoop的一个工具， 它帮助用户创建和运行一类特殊的map/reduce作业， 这些特殊的map/reduce作业是由一些可执行文件或脚本文件充当mapper或者reducer。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$HADOOP_HOME/bin/hadoop  jar $HADOOP_HOME/hadoop-streaming.jar \</span><br><span class="line">    -input myInputDirs \</span><br><span class="line">    -output myOutputDir \</span><br><span class="line">    -mapper /bin/cat \</span><br><span class="line">    -reducer /bin/wc</span><br><span class="line">    -file /home/Waterkong/test.sh</span><br></pre></td></tr></table></figure></p><h5 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h5><ul><li>-mapper与-reducer都可以指定一个可执行文件（可以是脚本，也可以是class文件），如果不需要map/reduce任务则可以省略对应的这个选项。</li><li>-file 任何可执行文件都可以被指定为mapper/reducer。这些可执行文件不需要事先存放在集群上； 如果在集群上还没有，则需要用-file选项让framework把可执行文件作为作业的一部分，一起打包提交。</li><li>一个说明图，说明这些作为Map或者Reduce的脚本与hadoop起的进程之间是怎么协作的。最重要的就是这些可执行文件是另起进程的。<br><img src="https://ws1.sinaimg.cn/large/005Owz0qly1fxqblwzuplj30qi0q0gn9.jpg" alt></li><li>以上就是一个简单的介绍，Hadoop Streaming具体介绍可以点击下面的链接<br><a href="https://hadoop.apache.org/docs/r1.0.4/cn/streaming.html#Hadoop+Streaming" target="_blank" rel="noopener">点击查看Hadoop Streaming的详细介绍</a></li></ul><h4 id="Hadoop-Distcp"><a href="#Hadoop-Distcp" class="headerlink" title="Hadoop Distcp"></a>Hadoop Distcp</h4><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h5><p>DistCp（分布式拷贝）是用于大规模集群内部和集群之间拷贝的工具。 它使用Map/Reduce实现文件分发，错误处理和恢复，以及报告生成。 它把文件和目录的列表作为map任务的输入，每个任务会完成源列表中部分文件的拷贝。 由于使用了Map/Reduce方法，这个工具在语义和执行上都会有特殊的地方。 这篇文档会为常用DistCp操作提供指南并阐述它的工作模型。</p><h5 id="基本使用方法："><a href="#基本使用方法：" class="headerlink" title="基本使用方法："></a>基本使用方法：</h5><p>DistCp最常用在集群之间的拷贝：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash$ hadoop distcp hdfs://nn1:8020/foo/bar \ </span><br><span class="line">                    hdfs://nn2:8020/bar/foo</span><br></pre></td></tr></table></figure></p><p>这条命令会把nn1集群的/foo/bar目录下的所有文件或目录名展开并存储到一个临时文件中，这些文件内容的拷贝工作被分配给多个map任务， 然后每个TaskTracker分别执行从nn1到nn2的拷贝操作。注意DistCp使用绝对路径进行操作。<br>命令行中可以指定多个源目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash$ hadoop distcp hdfs://nn1:8020/foo/a \ </span><br><span class="line">                    hdfs://nn1:8020/foo/b \ </span><br><span class="line">                    hdfs://nn2:8020/bar/foo</span><br></pre></td></tr></table></figure></p><p>或者使用-f选项，从文件里获得多个源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash$ hadoop distcp -f hdfs://nn1:8020/srclist \ </span><br><span class="line">                       hdfs://nn2:8020/bar/foo</span><br></pre></td></tr></table></figure></p><p>其中srclist 的内容是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs://nn1:8020/foo/a </span><br><span class="line">hdfs://nn1:8020/foo/b</span><br></pre></td></tr></table></figure></p><h5 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h5><p>问题：源目录之前的hdfs://是可以省略的，但是省略后他默认的HDFS的地址是怎么找到的？<br>因为是Hadoop的工具所以去默认的Hadoop环境找,在core-site.xml发现了默认的文件系统(HDFS)的地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">&lt;value&gt;hdfs://Waterkong&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p><p>但后面的这个hdfs://Waterkong是ping不通的。<br>因为配置了高可用，真正投入使用的namenode的地址还指不定是哪一个，所以这个真正的地址还要去hdfs-site.xml中查找现在正在使用的namanode的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.http-address.Waterkong.nn1&lt;/name&gt;</span><br><span class="line">&lt;value&gt;rsync.nn1.Waterkong.zw.ted:50070&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;dfs.namenode.http-address.Waterkong.nn2&lt;/name&gt;</span><br><span class="line">&lt;value&gt;rsync.nn2.Waterkong.sjs.ted:50070&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p><p>以上是HA节点真正的地址，至此客户端与服务端交互地址被找到。（这儿的nn1与nn2分别代表主备namenode，与上面的例子中的nn1,nn2没有关系。）<br>以上就是一个简单的介绍，Hadoop Distcp具体介绍可以点击下面的链接<br><a href="https://hadoop.apache.org/docs/r1.0.4/cn/distcp.html" target="_blank" rel="noopener">点击查看Hadoop Distcp的详细介绍</a><br>如有错误，敬请指导。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天总结一下经手的一个项目中用到的Hadoop工具；&lt;br&gt;距离上一篇文章不知不觉快4个月过去了，期间经历了毕业，入职这些事儿。一直想写个求职总结，错过了当初那份激情，现在已经有点淡忘那种真真切切的朝不保夕的感受。看后来有没有心情在更吧。我毕设也挺好玩，挺简单的一个东西，有时间也可以写写。这都是后话。&lt;br&gt;
    
    </summary>
    
      <category term="Hadoop" scheme="https://kongdada.github.io/categories/Hadoop/"/>
    
    
      <category term="hadoop" scheme="https://kongdada.github.io/tags/hadoop/"/>
    
      <category term="Streaming" scheme="https://kongdada.github.io/tags/Streaming/"/>
    
      <category term="Distcp" scheme="https://kongdada.github.io/tags/Distcp/"/>
    
  </entry>
  
  <entry>
    <title>一点资讯技术面总结</title>
    <link href="https://kongdada.github.io/2018/04/19/YiDianZiXun/"/>
    <id>https://kongdada.github.io/2018/04/19/YiDianZiXun/</id>
    <published>2018-04-19T12:26:07.000Z</published>
    <updated>2020-01-13T03:42:26.988Z</updated>
    
    <content type="html"><![CDATA[<p>感谢一点资讯给的面试机会；<br>以前文章提到过的不在赘述，记录新的知识点。<br><a id="more"></a></p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Linux命令用法查询网站：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">Click to jump</a></p><h5 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h5><p>wc统计文件里面有多少单词，多少行，多少字符。<br>语法:<br>[root@www ~]# wc [-lwm]<br>选项与参数：<br>-l  ：仅列出行；<br>-w  ：仅列出多少字(英文单字)；<br>-m  ：多少字符；<br>eg:<br>默认使用wc统计/etc/passwd</p><ul><li>#wc /etc/passwd<br>40   45 1719 /etc/passwd<br>40是行数，45是单词数，1719是字节数</li><li>#wc -l /etc/passwd   #统计行数，在对记录数时，很常用<br>40 /etc/passwd       #表示系统有40个账户</li><li>#wc -w /etc/passwd  #统计单词出现次数<br>45 /etc/passwd</li><li>#wc -m /etc/passwd  #统计文件的字符数<br>1719<h5 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h5>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。<br>常见用法：</li><li>在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行：<br>grep match_pattern file_name<br>grep “match_pattern” file_name<br>在多个文件中查找：<br>grep “match_pattern” file_1 file_2 file_3 …</li><li>输出除了匹配到的之外的所有行 -v 选项：<br>grep -v “match_pattern” file_name</li><li>使用正则表达式 -E 选项：<br>grep -E “[1-9]+”<br>或<br>egrep “[1-9]+”</li><li>统计文件或者文本中包含匹配字符串的行数 -c 选项：<br>grep -c “text” file_name</li><li>输出包含匹配字符串的行数 -n 选项：<br>grep “text” -n file_name<br>或<br>cat file_name | grep “text” -n<br>#多个文件<br>grep “text” -n file_1 file_2<h5 id="date"><a href="#date" class="headerlink" title="date"></a>date</h5></li><li>格式化输出：<br>date + “%Y%m%d”</li><li>前一天：<br>date -d “1 day ago” + date +”%Y-%m-%d”<ul><li>加减操作：<br>date +%Y%m%d                   //显示前天年月日<br>date -d “+1 day” +%Y%m%d       //显示前一天的日期<br>date -d “-1 day” +%Y%m%d       //显示后一天的日期<br>date -d “-1 month” +%Y%m%d     //显示上一月的日期<br>date -d “+1 month” +%Y%m%d     //显示下一月的日期<br>date -d “-1 year” +%Y%m%d      //显示前一年的日期<br>date -d “+1 year” +%Y%m%d      //显示下一年的日期</li></ul></li><li>设定时间：<br>date -s                //设置当前时间，只有root权限才能设置，其他只能查看<br>date -s 20120523       //设置成20120523，这样会把具体时间设置成空00:00:00<br>date -s 01:01:01       //设置具体时间，不会对日期做更改<br>date -s “01:01:01 2012-05-23”  //这样可以设置全部时间<br>date -s “01:01:01 20120523”    //这样可以设置全部时间<br>date -s “2012-05-23 01:01:01”  //这样可以设置全部时间<br>date -s “20120523 01:01:01”    //这样可以设置全部时间<h5 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h5>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab文件都被保存在/var/spool/cron目录中。其文件名与用户名一致，使用者权限文件如下：<br>/etc/cron.deny     该文件中所列用户不允许使用crontab命令<br>/etc/cron.allow    该文件中所列用户允许使用crontab命令<br>/var/spool/cron/   所有用户crontab文件存放的目录,以用户名命名</li></ul><p>crontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p><blockquote><p>minute   hour   day   month   week   command     顺序：分 时 日 月 周</p></blockquote><p>其中：<br>minute： 表示分钟，可以是从0到59之间的任何整数。<br>hour：表示小时，可以是从0到23之间的任何整数。<br>day：表示日期，可以是从1到31之间的任何整数。<br>month：表示月份，可以是从1到12之间的任何整数。<br>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。<br>在以上各个字段中，还可以使用以下特殊字符：<br>星号（<em>）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如</em>/10，如果用在minute字段，表示每十分钟执行一次。<br><a href="http://man.linuxde.net/crontab" target="_blank" rel="noopener">详细用法链接：</a></p><h4 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h4><h5 id="给出一个数组-0，1，1，1，2，2，3，3，4，4，5，6，7，8，8-，求出现次数最多的那个数字出现次数，显然应该返回1，出现3次；"><a href="#给出一个数组-0，1，1，1，2，2，3，3，4，4，5，6，7，8，8-，求出现次数最多的那个数字出现次数，显然应该返回1，出现3次；" class="headerlink" title="给出一个数组{0，1，1，1，2，2，3，3，4，4，5，6，7，8，8}，求出现次数最多的那个数字出现次数，显然应该返回1，出现3次；"></a>给出一个数组{0，1，1，1，2，2，3，3，4，4，5，6，7，8，8}，求出现次数最多的那个数字出现次数，显然应该返回1，出现3次；</h5><p>当时的想法是采用桶，给出数组中的元素做下标，出现一次，对应桶的值+1；<br>但有问题，如果给出的数组特别大，那么空间复杂度就高，甚至内存溢出；<br>所以采取新的思路，用HashMap&lt;Integer, Integer&gt;,数组元素做key，出现次数做value;遍历数组，出现一次，value++；<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package YiDianZiXun;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">// 找到出现次数最多的那个数，和出现的次数；</span><br><span class="line">public class CountTimes &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = &#123; 0, 1, 1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 6, 7, 8, 8 &#125;;</span><br><span class="line">int[] res = MaxTimes(arr);</span><br><span class="line">System.out.println(&quot;数字：&quot; + res[0] + &quot; 出现次数： &quot; + res[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int[] MaxTimes(int[] arr) &#123;</span><br><span class="line">if(arr == null || arr.length &lt; 1)</span><br><span class="line">return new int[] &#123;&#125;;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">int times = 0;</span><br><span class="line">int num = 0;</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">if (map.get(arr[i]) == null) &#123;</span><br><span class="line">map.put(arr[i], 1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">Integer value = map.get(arr[i]) + 1;</span><br><span class="line">map.put(arr[i], value);</span><br><span class="line">if (value &gt; times) &#123;</span><br><span class="line">times = value;</span><br><span class="line">num = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return new int[] &#123; num, times &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="给出一个数组-1，0，1，2，3，0，1，4，-1，0-，求和为零的最长连续子序列；"><a href="#给出一个数组-1，0，1，2，3，0，1，4，-1，0-，求和为零的最长连续子序列；" class="headerlink" title="给出一个数组{-1，0，1，2，3，0，1，4，-1，0}，求和为零的最长连续子序列；"></a>给出一个数组{-1，0，1，2，3，0，1，4，-1，0}，求和为零的最长连续子序列；</h5><p>思路：定义sum(i)是数组的前i项和；<br>我们假设从i+1位置到j位置的和为零，那么我们可以得到sum(i) == sum(j)；<br>计算sum(i)，用一个map记录这个和，以及这个和第一次出现的位置；<br>如果一个和不是第一次出现，也就是存在sum(i) == sum(j)；j &gt; i；<br>那么从i+1 到 j位置的和就是零；长度为(j - i);<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package YiDianZiXun;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">// 求一个数组所有子数组中和为零子数组长度最长的。</span><br><span class="line">public class SubArrIsZero &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = &#123; -1, 0, 1, 2, 3, 0, 1, 4, -1, 0 &#125;;</span><br><span class="line">int len = GetMaxLength(arr);</span><br><span class="line">System.out.println(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int GetMaxLength(int[] arr) &#123;</span><br><span class="line">if (arr == null || arr.length &lt; 1)</span><br><span class="line">return 0;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">// 为了解决从开头第一个位置有一个子数组就是所求</span><br><span class="line">map.put(0, -1);</span><br><span class="line">int sum = 0;</span><br><span class="line">int len = 0;</span><br><span class="line">for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">sum += arr[i];</span><br><span class="line">if (!map.containsKey(sum)) &#123;</span><br><span class="line">map.put(sum, i);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">int left = map.get(sum);</span><br><span class="line">len = Math.max(len, (i - left));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="手撸快排"><a href="#手撸快排" class="headerlink" title="手撸快排"></a>手撸快排</h5><p>排序的重要性不言而喻，在我有限的面试中就已经手写了两次快排了;<br>归并，堆排序，都需要掌握；</p><h5 id="一个总结递推公式的题："><a href="#一个总结递推公式的题：" class="headerlink" title="一个总结递推公式的题："></a>一个总结递推公式的题：</h5><p>这类题只要有递推公式以及边界条件，剩下的就是代码优化；<br>有一个 2xN 的区域，现在用N个2x1的矩形去填充，问总共有多少种方式？<br>破题点：最后一块怎么放？<br>分情况：<br>最后一块竖着放，那么使用前n-1块的形成的方案数量等于用n块的方案数量；<br>最后一块横着放，那么第n-1块必然也是横着放，所以使用前n-2块形成的方案数量等于使用n块的方案数量；<br>那么总方案数量等于以上两种情况的和：f(n) = f(n-1) + f(n-2);<br>且f(1) = 1, f(2) = 2;<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package YiDianZiXun;</span><br><span class="line">// 矩形覆盖问题</span><br><span class="line">public class Fibonacci &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int n = 3;</span><br><span class="line">int res = RectCover(n);</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int RectCover(int target) &#123;</span><br><span class="line">if (target == 0)</span><br><span class="line">return 1;</span><br><span class="line">if (target &lt; 3)</span><br><span class="line">return target;</span><br><span class="line">int pre = 1;</span><br><span class="line">int cur = 2;</span><br><span class="line">int res = 0;</span><br><span class="line">for (int i = 3; i &lt;= target; i++) &#123;</span><br><span class="line">res = pre + cur;</span><br><span class="line">pre = cur;</span><br><span class="line">cur = res;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><h5 id="between-and-用法；"><a href="#between-and-用法；" class="headerlink" title="between and 用法；"></a>between and 用法；</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢一点资讯给的面试机会；&lt;br&gt;以前文章提到过的不在赘述，记录新的知识点。&lt;br&gt;
    
    </summary>
    
      <category term="Interview" scheme="https://kongdada.github.io/categories/Interview/"/>
    
    
      <category term="算法" scheme="https://kongdada.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Linux" scheme="https://kongdada.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>搜狗技术面总结</title>
    <link href="https://kongdada.github.io/2018/04/18/SouGou/"/>
    <id>https://kongdada.github.io/2018/04/18/SouGou/</id>
    <published>2018-04-18T08:08:01.000Z</published>
    <updated>2020-01-13T03:42:26.987Z</updated>
    
    <content type="html"><![CDATA[<p>感谢搜狗给的面试机会，感谢技术面大佬；<br>基本按着简历问的，这篇整理以前面试中提到的不在赘述；<br>记录一些新的或者没注意到得细节；<br><a id="more"></a></p><h4 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h4><h5 id="HQL中的join与MR的转换"><a href="#HQL中的join与MR的转换" class="headerlink" title="HQL中的join与MR的转换"></a>HQL中的join与MR的转换</h5><p>map阶段整体上来说就是将表中的每一条记录，转换为key-value形式；<br>一般都是on后的条件字段做key，其他字段做value，但是value中要加一个字段就是当前记录来自那张表；<br>shuffle阶段：将相同key的记录整理到一起；<br>reduce阶段： 将拥有相同key，但来自不同表，的字段进行整合，做成一条记录；</p><h5 id="分区的认识"><a href="#分区的认识" class="headerlink" title="分区的认识"></a>分区的认识</h5><p>Hive中的join操作会扫描全表，当表比较大时，这样扫描耗时长，效率低；<br>引进分区，可以理解为是将表进行了划分，我们可以在join操作是指定分区，这样就只扫描指定的分区，不做全表扫描，节约时间，提高效率；</p><h4 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h4><h5 id="客户端向HDFS写操作中间如果发生了失败，后续是怎么处理的；"><a href="#客户端向HDFS写操作中间如果发生了失败，后续是怎么处理的；" class="headerlink" title="客户端向HDFS写操作中间如果发生了失败，后续是怎么处理的；"></a>客户端向HDFS写操作中间如果发生了失败，后续是怎么处理的；</h5><p>整个写流程如下：</p><ul><li>第一步，客户端调用DistributedFileSystem的create()方法，开始创建新文件：DistributedFileSystem创建DFSOutputStream，产生一个RPC调用，让NameNode在文件系统的命名空间中创建这一新文件；</li><li>第二步，NameNode接收到用户的写文件的RPC请求后，谁偶先要执行各种检查，如客户是否有相关的创佳权限和该文件是否已存在等，检查都通过后才会创建一个新文件，并将操作记录到编辑日志，然后DistributedFileSystem会将DFSOutputStream对象包装在FSDataOutStream实例中，返回客户端；否则文件创建失败并且给客户端抛IOException。</li><li>第三步，客户端开始写文件：DFSOutputStream会将文件分割成packets数据包，然后将这些packets写到其内部的一个叫做data queue(数据队列)。data queue会向NameNode节点请求适合存储数据副本的DataNode节点的列表，然后这些DataNode之前生成一个Pipeline数据流管道，我们假设副本集参数被设置为3，那么这个数据流管道中就有三个DataNode节点。</li><li>第四步，首先DFSOutputStream会将packets向Pipeline数据流管道中的第一个DataNode节点写数据，第一个DataNode接收packets然后把packets写向Pipeline中的第二个节点，同理，第二个节点保存接收到的数据然后将数据写向Pipeline中的第三个DataNode节点。</li><li>第五步，DFSOutputStream内部同样维护另外一个内部的写数据确认队列——ack queue。当Pipeline中的第三个DataNode节点将packets成功保存后，该节点回向第二个DataNode返回一个确认数据写成功的信息，第二个DataNode接收到该确认信息后在当前节点数据写成功后也会向Pipeline中第一个DataNode节点发送一个确认数据写成功的信息，然后第一个节点在收到该信息后如果该节点的数据也写成功后，会将packets从ack queue中将数据删除。<br><strong>在写数据的过程中，如果Pipeline数据流管道中的一个DataNode节点写失败了会发生什问题、需要做哪些内部处理呢？如果这种情况发生，那么就会执行一些操作：<br>首先，Pipeline数据流管道会被关闭，ack queue中的packets会被添加到data queue的前面以确保不会发生packets数据包的丢失；<br>接着，在正常的DataNode节点上的以保存好的block的ID版本会升级——这样发生故障的DataNode节点上的block数据会在节点恢复正常后被删除，失效节点也会被从Pipeline中删除；<br>最后，剩下的数据会被写入到Pipeline数据流管道中的其他两个节点中。<br>如果Pipeline中的多个节点在写数据是发生失败，那么只要写成功的block的数量达到dfs.replication.min(默认为1)，那么就任务是写成功的，然后NameNode后通过一步的方式将block复制到其他节点，最后事数据副本达到dfs.replication参数配置的个数。</strong></li><li>第六步，，完成写操作后，客户端调用close()关闭写操作，刷新数据；</li><li>第七步，，在数据刷新完后NameNode后关闭写操作流。到此，整个写操作完成。</li></ul><h5 id="HDFS的HA（高可用）实现中采用了QJM，详细介绍一下；"><a href="#HDFS的HA（高可用）实现中采用了QJM，详细介绍一下；" class="headerlink" title="HDFS的HA（高可用）实现中采用了QJM，详细介绍一下；"></a>HDFS的HA（高可用）实现中采用了QJM，详细介绍一下；</h5><p>一句话：通过共享存储，共享了编辑日志；<br>怎么保证了高可用，活动的NN写编辑日志需要写入大多数JN节点，才能完成写操作；<br>这样就可以保证编辑日志是同步的，所以备用NN只要拿到编辑日志，然后根据编辑日志，重做元数据，就能到的最新的元数据，保证了高可用；</p><ul><li>比较详细的解释：<br>在高可用配置下，editlog不再存放在名称节点，而是存放在一个共享存储的地方，这个共享存储由奇数个Journal Node组成，一般是3个节点(JN小集群)， <strong>每个JN专门用于存放来自NN的编辑日志</strong>，编辑日志由活跃状态的名称节点写入JN小集群。<br>那么要有2个NN，而且二者之中只能有一个NN处于活跃状态（active），另一个是待命状态（standby），只有active的NN节点才能对外提供读写HDFS服务，也只有active态的NN才能向JN写入编辑日志；standby状态的NN负责从JN小集群中拷贝数据（这个数据就是编辑日志）到本地。另外，各个DATA NODE也要同时向两个名称节点报告状态(心跳信息、块信息)</li></ul><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><h5 id="HashMap为什么线程不安全，或者说hashMap的线程不安全表现在哪；"><a href="#HashMap为什么线程不安全，或者说hashMap的线程不安全表现在哪；" class="headerlink" title="HashMap为什么线程不安全，或者说hashMap的线程不安全表现在哪；"></a>HashMap为什么线程不安全，或者说hashMap的线程不安全表现在哪；</h5><ul><li>多线程下Resize操作，可能会形成链表环<br>Hashmap在插入元素过多的时候需要进行Resize，Resize的条件是<br>HashMap.Size   &gt;=  Capacity * LoadFactor。<br>Hashmap的Resize包含扩容和ReHash两个步骤，ReHash在并发的情况下可能会形成链表环<br><a href="http://mp.weixin.qq.com/s/dzNq50zBQ4iDrOAhM4a70A" target="_blank" rel="noopener">点击查看形成链表环的详细解释</a></li><li>同时addEntry<br>两个线程同时获得了数组的一个位置，对一个Entry进行put操作，两个线程都有可能先执行，那么一个线程必然覆盖另一个线程的写入结果。安全的方式是不能同时获得同一个节点，写操作不能相互覆盖；</li></ul><h5 id="将M个长度为N的有序数组进行Merge，这个过程的时间复杂度；"><a href="#将M个长度为N的有序数组进行Merge，这个过程的时间复杂度；" class="headerlink" title="将M个长度为N的有序数组进行Merge，这个过程的时间复杂度；"></a>将M个长度为N的有序数组进行Merge，这个过程的时间复杂度；</h5><p>要将M个有序数组合并，我的想法是一直两两合并，直到最后合并成一个，<br>一对（两个）有序数组合并，他们要执行比较语句2N次，<br>第一步：有M/2对，要比较2N次，<code>M/2 * 2N = MN;</code><br>第二步：有M/4对，要比较4N次（合并后长度是上一次的两倍），<code>M/4 * 4N = MN;</code><br>…<br>直到合并成一个，这是一个分步计算，所以最终比较次数是以上每一步相加的和；<br>又因为大O表示法只取最高次项，所以最终这个时间复杂度为：O(MN)</p><h5 id="java-的IO流如果不关闭会造成什么后果；"><a href="#java-的IO流如果不关闭会造成什么后果；" class="headerlink" title="java 的IO流如果不关闭会造成什么后果；"></a>java 的IO流如果不关闭会造成什么后果；</h5><p>占用资源，内存溢出；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢搜狗给的面试机会，感谢技术面大佬；&lt;br&gt;基本按着简历问的，这篇整理以前面试中提到的不在赘述；&lt;br&gt;记录一些新的或者没注意到得细节；&lt;br&gt;
    
    </summary>
    
      <category term="Interview" scheme="https://kongdada.github.io/categories/Interview/"/>
    
    
      <category term="hadoop" scheme="https://kongdada.github.io/tags/hadoop/"/>
    
      <category term="HashMap" scheme="https://kongdada.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>创智优品面试总结</title>
    <link href="https://kongdada.github.io/2018/04/10/Zonjey/"/>
    <id>https://kongdada.github.io/2018/04/10/Zonjey/</id>
    <published>2018-04-10T14:00:49.000Z</published>
    <updated>2020-01-13T03:42:26.989Z</updated>
    
    <content type="html"><![CDATA[<p>4.08号，创智优品面试，学长内推，一面被拒。两个算法题；<br><a id="more"></a></p><h4 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h4><h5 id="题目一："><a href="#题目一：" class="headerlink" title="题目一："></a>题目一：</h5><p>给你一棵二叉树，找到距离最远的两个节点；<br>（从A节点出发，可以向上或者向下走，沿途的节点只能经过一次，当到达B节点时，路径上的节点数叫做A到B的距离）<br>思路：分三种情况假设给出的根为root</p><ul><li>root的左子树上的最大距离；</li><li>root的右子树上的最大距离；</li><li>跨越root，左子树距离root的最远距离 + 1 + 右子树距离root最远的距离；<br>在这三个距离中取最大的一个就是所求；<br>代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 我们需要一个独立于递归函数之外的变量，不受递归影响，还要递归函数能够改变，所以采用了一个record；</span><br><span class="line">private static int maxDistance(Node head) &#123;</span><br><span class="line">  int[] record = new int[1];</span><br><span class="line">  return posOrder(head, record);</span><br><span class="line">&#125;</span><br><span class="line">// 递归函数，设置递归，确定边界；</span><br><span class="line">private static int posOrder(Node head, int[] record) &#123;</span><br><span class="line">  if(head == null) &#123;</span><br><span class="line">    record[0] = 0;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  int lmax = posOrder(head.left, record);</span><br><span class="line">  int maxfromLeft = record[0];</span><br><span class="line">  int rmax = posOrder(head.right, record);</span><br><span class="line">  int maxfromRight = record[0];</span><br><span class="line">  int curNodeMax = maxfromLeft + maxfromRight + 1;</span><br><span class="line">  record[0] = Math.max(maxfromLeft, maxfromRight) + 1;</span><br><span class="line">  return Math.max(Math.max(lmax, rmax), curNodeMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目二：手写快速排序；"><a href="#题目二：手写快速排序；" class="headerlink" title="题目二：手写快速排序；"></a>题目二：手写快速排序；</h5><p>这个就直接上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class quick_sort &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = &#123;1,4,7,2,5,8,3,6,9,5,4&#125;;</span><br><span class="line">quickSort(arr, 0, arr.length-1);</span><br><span class="line">System.out.println(&quot;最终结果：&quot; + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void quickSort(int[] arr, int i, int j) &#123;</span><br><span class="line">if(i &gt;= j)</span><br><span class="line">return ;</span><br><span class="line">else &#123;</span><br><span class="line">int index = partition(arr, i, j);</span><br><span class="line">System.out.println(&quot;index: &quot; + index);</span><br><span class="line">quickSort(arr, i, index-1);</span><br><span class="line">quickSort(arr, index+1, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 返回基准的下标</span><br><span class="line">private static int partition(int[] arr, int low, int heigh) &#123;</span><br><span class="line">int key = arr[low];</span><br><span class="line">while(low &lt; heigh) &#123;</span><br><span class="line">// 这儿要说明的一点是：必须先从后往前比，因为前面用key记住了基准，空开了一个位置</span><br><span class="line">// 所以从后向前比较发现一个小于基准的数字，放在这个空开的位置；</span><br><span class="line">while(arr[heigh] &gt;= key &amp;&amp; low &lt; heigh) &#123;</span><br><span class="line">heigh--;</span><br><span class="line">&#125;</span><br><span class="line">// 在后面找到了小于基准的数，放在基准前；同时后面空出了一个位置，所以从前面找一个</span><br><span class="line">// 大于基准的数，放在这个位置上；</span><br><span class="line">arr[low] = arr[heigh];</span><br><span class="line">//从前向后比较</span><br><span class="line">while(arr[low] &lt;= key &amp;&amp; low &lt; heigh) &#123;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line">// 这儿就是在前面发现了一个大于基准的数，把他放在后面的位置上；</span><br><span class="line">arr[heigh] = arr[low];</span><br><span class="line">// 至此，小于基准的位于一边，大于基准的位于另一边；</span><br><span class="line">System.out.println(&quot;前后置换一次：&quot; + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line">arr[heigh] = key;</span><br><span class="line">return heigh;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><h5 id="java垃圾回收算法"><a href="#java垃圾回收算法" class="headerlink" title="java垃圾回收算法"></a>java垃圾回收算法</h5><ol><li>标记 - 清除<br>将需要回收的对象进行标记，然后清除。<br>不足：两点：效率问题和时间空间问题</li></ol><ul><li>标记和清除过程效率都不高</li><li>会产生大量碎片，内存碎片过多可能导致无法给大对象分配内存<br>之后的算法都是基于该算法进行改进。</li></ul><ol start="2"><li>复制</li></ol><ul><li>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</li><li>主要不足是只使用了内存的一半。</li><li>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和 使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间。</li><li>IBM研究表明，98%的对象都是朝生夕死，</li><li>分配担保：存活对象超过了survivor的内存，通过分配担保机直接进入老年代<h5 id="一个需要理解的细节"><a href="#一个需要理解的细节" class="headerlink" title="一个需要理解的细节"></a>一个需要理解的细节</h5>在交流过程中有一个细节，没有掌握清楚，记录在下面<br>问题：分代垃圾回收中，既然复制算法效率高，速度快，为什么老年代没有采取复制算法？</li><li>复制算法适用的场景是大多数对象都有一个很短的生存期，所以复制时会有少量的对象被复制到survivor区；老年代正好与此相反，大多数对象都有一个比较长的生存期，所以会造成每一次回收都必须复制大量的对象，效率必然不高；</li><li>最根本的缺陷，复制算法在垃圾回收时，如果存活的对象所占的内存大于survivor区域，此时年轻代的解决方案是用老年代的内存做分配担保；如果复制算法用在了老年代垃圾回收上，因为老年代对象的生存期长，很可能会发生survivor区域内存不足，此时却没有任何区域给老年代做分配担保；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;4.08号，创智优品面试，学长内推，一面被拒。两个算法题；&lt;br&gt;
    
    </summary>
    
      <category term="Interview" scheme="https://kongdada.github.io/categories/Interview/"/>
    
    
      <category term="Interview" scheme="https://kongdada.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>便利蜂技术面总结</title>
    <link href="https://kongdada.github.io/2018/04/01/bianLiFeng/"/>
    <id>https://kongdada.github.io/2018/04/01/bianLiFeng/</id>
    <published>2018-04-01T11:38:46.000Z</published>
    <updated>2020-01-13T03:42:26.991Z</updated>
    
    <content type="html"><![CDATA[<p>3.30号，下午请假去北邮参加校园宣讲会，现场笔试，直接三道编程题；<br><a id="more"></a></p><h4 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h4><h5 id="第一道：给出一个正整数数组，返回他能组成的最大整数。"><a href="#第一道：给出一个正整数数组，返回他能组成的最大整数。" class="headerlink" title="第一道：给出一个正整数数组，返回他能组成的最大整数。"></a>第一道：给出一个正整数数组，返回他能组成的最大整数。</h5><p>举个例子arr = {19, 9, 912} 他应该组成的最大数为9 912 19；<br>就是说数组中每个元素都不可以分割开。<br>思路：首先将整数数组转换为一个字符串数组，每个元素都是一个字符串；<br>找到元素中长度最长的那个，在例子中就是长度为3的 “912”；<br>将其他的元素用他本身的最后一个字符补充至长度3，得到 “912”, “999”, “199”;<br>现在将元素排序得到 “999”,”912”,”199”;<br>最后将补充的字符都删除，即可得到：9 912 199；<br>代码很杂乱，不献丑了；<br>方法二：<br>用到了贪心策略，局部最优，推广到整体。引进一个比较器，自定义比较方式；<br>例如，在自定义之前是按字典序排序，该字符串数组排序结果为：”19” “9” “912”，举例子，显然我们需要的不是”19” &lt; “9”，我们需要的是链接后“199”&lt;”919”的顺序,需要的是”9129” &lt; “9912”,类似于这种，就是说我们需要的是链接后的顺序，不要链接前的顺序。贪心策略的证明很难，暂时不会，代码暂时没有问题；<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package bianlifeng;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class improveSolution1 &#123;</span><br><span class="line">public static class MyComparator implements Comparator&lt;String&gt;&#123;</span><br><span class="line">@Override</span><br><span class="line">public int compare(String str1, String str2) &#123;</span><br><span class="line">return (str1+str2).compareTo(str2+str1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = &#123;18,89,12,56,4,3,7&#125;;</span><br><span class="line">String[] strArr = new String[arr.length];</span><br><span class="line">for(int i=0; i &lt; arr.length;i++) &#123;</span><br><span class="line">strArr[i] = arr[i] + &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(strArr);</span><br><span class="line">System.out.println(&quot;不用比较器：&quot; + Arrays.toString(strArr));</span><br><span class="line">Arrays.sort(strArr, new MyComparator());</span><br><span class="line">System.out.println(&quot;用比较器： &quot; + Arrays.toString(strArr));</span><br><span class="line">for(int i = strArr.length-1 ; i &gt;= 0; i--) &#123;</span><br><span class="line">System.out.print(strArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="第二道：给出一个数组arr，长度为n-每一个元素代表存在的货币值，现在给出一个aim，求最少用几张货币能够组成这个整数aim，每张货币不限使用次数。"><a href="#第二道：给出一个数组arr，长度为n-每一个元素代表存在的货币值，现在给出一个aim，求最少用几张货币能够组成这个整数aim，每张货币不限使用次数。" class="headerlink" title="第二道：给出一个数组arr，长度为n;每一个元素代表存在的货币值，现在给出一个aim，求最少用几张货币能够组成这个整数aim，每张货币不限使用次数。"></a>第二道：给出一个数组arr，长度为n;每一个元素代表存在的货币值，现在给出一个aim，求最少用几张货币能够组成这个整数aim，每张货币不限使用次数。</h5><ul><li>经典的动态规划问题，构建dp矩阵，n行aim+1列；</li><li>第一列：aim = 0,自然第一列都是0；</li><li>第一行，自然只有k倍的arr[0]的地方有对应的次数，举个例子，假设arr[0] = 2;<br>那么aim 只会等于2，4，6，8,这个样子，也就是在aim等于2的倍数的地方分别初始化为1，2，3，4；</li><li>其他位置dp[i][j] = min(dp[i-1][j], dp[i][j-arr[i]] + 1);</li><li>要注意的几个点，其实初始化0的地方就可以不初始化了，本来就是0；<br>初始化第一行包括后面的dp[i][j],都应该先初始化为max然后满足条件的地方初始化为对应的值，因为后续处理中有个比较要取小值，会有影响；<ul><li>代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package bianlifeng;</span><br><span class="line">public class impoveSolution2 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = &#123; 1, 7, 8, 9, 20, 50 &#125;;</span><br><span class="line">int aim = 15;</span><br><span class="line">int res = minCoins(arr, aim);</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int minCoins(int[] arr, int aim) &#123;</span><br><span class="line">int n = arr.length;</span><br><span class="line">int[][] dp = new int[n][aim + 1];</span><br><span class="line">int max = Integer.MAX_VALUE;</span><br><span class="line">// 初始化第一列</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">dp[i][0] = 0;</span><br><span class="line">&#125;</span><br><span class="line">// 初始化第一行</span><br><span class="line">for (int j = 1; j &lt;= aim; j++) &#123;</span><br><span class="line">dp[0][j] = max;</span><br><span class="line">if (j &gt;= arr[0] &amp;&amp; dp[0][j - arr[0]] != max) &#123;</span><br><span class="line">dp[0][j] = dp[0][j - arr[0]] + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 计算其他位置</span><br><span class="line">int left = 0;</span><br><span class="line">for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt;= aim; j++) &#123;</span><br><span class="line">left = max;</span><br><span class="line">if (j &gt;= arr[i] &amp;&amp; dp[i][j - arr[i]] != max) &#123;</span><br><span class="line">left = dp[i][j - arr[i]] + 1;</span><br><span class="line">&#125;</span><br><span class="line">dp[i][j] = Math.min(left, dp[i - 1][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return dp[n - 1][aim];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="第三道：LRU最近最常使用；"><a href="#第三道：LRU最近最常使用；" class="headerlink" title="第三道：LRU最近最常使用；"></a>第三道：LRU最近最常使用；</h5><p>详细：因为内存有限，所以维持一个使用频率最高的数字集。<br>例如有序列4 2 3 4 1 2 3<br>假设维持的物理块为3则有。</p><ul><li>4进，维持数组 4</li><li>2进，维持2 4</li><li>3进，维持3 2 4</li><li>4进，维持4 3 2</li><li>1进，维持1 4 3</li><li>2进，维持2 1 4</li><li>3进，维持，3 2 1</li><li>现在需要你构造一个数据结构满足以上条件。</li><li>要有 get(key)若key存在则返回对应值。若不存在返回null</li><li>要有set（key, value），若key不存在，则直接保存，若key存在，更新value。不能使用语言中已经存在的实现类。</li></ul><h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><p>第一部分是java的面试官；</p><ol><li>HashMap的底层实现。<br>HashMap内部维护了一个存储数据的Entry数组，HashMap采用链表解决冲突，每一个Entry本质上是一个单向链表。当准备添加一个key-value对时，首先通过hash(key)方法计算hash值，然后通过indexFor(hash,length)求该key-value对的存储位置，计算方法是先用hash&amp;0x7FFFFFFF后，再对length取模，这就保证每一个key-value对都能存入HashMap中，当计算出的位置相同时，由于存入位置是一个链表，则把这个key-value对插入链表头。</li><li>假设我自己定义HashMap，只用数组存储，当冲突的时候向后放，这样实现的根本性的缺陷是什么？</li><li>HashMap的扩展过程；</li></ol><ul><li>HashMap内存储数据的Entry数组默认是16，如果没有对Entry扩容机制的话，当存储的数据一多，Entry内部的链表会很长，这就失去了HashMap的存储意义了。所以HasnMap内部有自己的扩容机制。HashMap内部有：</li><li>变量size，它记录HashMap的底层数组中已用槽的数量；</li><li>变量threshold，它是HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）    </li><li>变量DEFAULT_LOAD_FACTOR = 0.75f，默认加载因子为0.75</li><li>HashMap扩容的条件是：当size大于threshold时，对HashMap进行扩容  </li><li>扩容是是新建了一个HashMap的底层数组，而后调用transfer方法，将就HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。 很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。</li><li>HashMap共有四个构造方法。构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（从构造函数中可以看出，如果不指明，则默认为16），加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。</li><li>下面说下加载因子，如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。</li><li>另外，无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;3.30号，下午请假去北邮参加校园宣讲会，现场笔试，直接三道编程题；&lt;br&gt;
    
    </summary>
    
      <category term="Interview" scheme="https://kongdada.github.io/categories/Interview/"/>
    
    
      <category term="Interview" scheme="https://kongdada.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>日志易技术面总结</title>
    <link href="https://kongdada.github.io/2018/03/29/RiZhiYi/"/>
    <id>https://kongdada.github.io/2018/03/29/RiZhiYi/</id>
    <published>2018-03-29T14:00:25.000Z</published>
    <updated>2020-01-13T03:42:26.987Z</updated>
    
    <content type="html"><![CDATA[<p>感谢日志易给的面试机会，感谢技术面大佬；<br>最后厚着脸皮要了个评语：基础知识还行，但是不够熟练;<br><a id="more"></a></p><h4 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h4><p>这一部分的话，回忆几个比较重要的（我回答错）点。</p><h5 id="字符串初始化与-比较"><a href="#字符串初始化与-比较" class="headerlink" title="字符串初始化与 == 比较"></a>字符串初始化与 == 比较</h5><p>题目：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;hello&quot;;</span><br><span class="line">String str2 = &quot;he&quot; + new String(&quot;llo&quot;);</span><br><span class="line">String str3 = &quot;he&quot; + &quot;llo&quot;;</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line">System.out.println(str1 == str3);</span><br></pre></td></tr></table></figure></p><p>结果：false  true</p><h5 id="自增与等于结合"><a href="#自增与等于结合" class="headerlink" title="自增与等于结合"></a>自增与等于结合</h5><p>题目：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">int y = ++i;</span><br><span class="line">System.out.println(i + &quot; &quot; + y);</span><br></pre></td></tr></table></figure></p><p>结果: 2 2</p><h5 id="不同修饰符，修饰后能引用的范围："><a href="#不同修饰符，修饰后能引用的范围：" class="headerlink" title="不同修饰符，修饰后能引用的范围："></a>不同修饰符，修饰后能引用的范围：</h5><p>public:  同一类，同一包，子孙类，不同包；<br>protect: 同一类，同一包，子孙类；<br>default: 同一类，同一包；<br>private: 同一类；</p><h5 id="原生类与引用数据类型；"><a href="#原生类与引用数据类型；" class="headerlink" title="原生类与引用数据类型；"></a>原生类与引用数据类型；</h5><p>原生类就是指java的8种基本类型，byte short int long float double char boolean；<br>引用数据类型：数组，类，接口；</p><h5 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h5><p>进程：是系统资源分配的基本单位，一个进程可以有多个线程；<br>线程：是CPU调度的基本类型，线程不拥有系统资源，可以访问隶属进程的资源；</p><h5 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h5><ul><li>管道（普通管道单向传递用在父子进程间，流管道可以双向传递用在父子进程间，命名管道单向传递可以用在不同进程间）</li><li>消息队列（克服了管道只能承载无格式字节流以及缓冲区受限）</li><li>套接字（可以用在不同机器的进程之间通信）；</li><li>共享内存：操作系统建立一块共享内存，映射到各个进程的地址，各个进程可以对这块共享内存进行读写，这是进程间通信的最快方式；</li></ul><h5 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h5><p>线程间的通信主要目的是用于线程同步</p><ul><li>锁机制：互斥锁，读写锁，条件变量等；</li><li>信号量机制： 无名线程信号量，有名先线程信号量；</li><li>信号机制：类似与进程间的信号处理；</li></ul><h5 id="HashMap的底层实现，哈希表的结构，冲突怎么解决的？"><a href="#HashMap的底层实现，哈希表的结构，冲突怎么解决的？" class="headerlink" title="HashMap的底层实现，哈希表的结构，冲突怎么解决的？"></a>HashMap的底层实现，哈希表的结构，冲突怎么解决的？</h5><h5 id="内存模型与垃圾回收"><a href="#内存模型与垃圾回收" class="headerlink" title="内存模型与垃圾回收"></a>内存模型与垃圾回收</h5><h5 id="设计模式的应用场景"><a href="#设计模式的应用场景" class="headerlink" title="设计模式的应用场景"></a>设计模式的应用场景</h5><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="题目一：给出一个n-代表有从1到n的数字-1-2-3-···-n-，问可以构成多少种二叉搜索树？"><a href="#题目一：给出一个n-代表有从1到n的数字-1-2-3-···-n-，问可以构成多少种二叉搜索树？" class="headerlink" title="题目一：给出一个n,代表有从1到n的数字[1,2,3,··· n]，问可以构成多少种二叉搜索树？"></a>题目一：给出一个n,代表有从1到n的数字[1,2,3,··· n]，问可以构成多少种二叉搜索树？</h5><p>一开始的想法是直接递归构造，时间复杂度是指数上升；<br>后来想法是找规律：<br>先看例子：</p><ul><li>n = 1, 有一个元素,可以构成一个二叉搜索树,左右都没有元素，总数量 = 左子树数量 <em> 右子树数量，记为f(1) = f(0) </em> f(0) = 1，这儿可以将f(0)初始化为1;</li><li>n = 2, 1做根，那么左子树没有元素记为f(0),右子树有一个元素记为f(1), 2做根，左子树有一个元素，记为f(1),右子树没有元素记为f(0);<br>总共：f(2) = f(0) <em> f(1) + f(1) </em> f(0) = 2;</li><li>n = 3, 1做根，数量 = f(0) <em> f(2), 2做根 数量 = f(1) </em> f(1), 3做根， 数量 = f(2) <em> f(0);<br>总共 f(3) = f(0) </em> f(2) + f(1) <em> f(1) + f(2) </em> f(0) = 5;<br>可以看出f(n),依赖与f(0)到f(n-1),换句话说可以有前面的n-1项推导出第n项；<br>分析关系表达式：</li><li>记h(k)为以k为根可以生成的二叉搜索树数量；</li><li>当以k为根时，他的左子树为[1,2 ··· k-1]构成，也就是左子树有k-1个元素构成，这个就可以记为f(k-1)；</li><li>右子树为[k+1 ··· n]构成，也就是右子树有n-k个元素构成，这个可以记为f(n-k)；</li><li>那么h(k) = f(k-1) * f(n-k); 要记得k的范围可以从1到n;</li><li>整合以上规律可得到：有n个元素的二叉搜索树的数量；f(n) = h(1)+h(2)+···+h(n) = ∑ h(k) ,0 &lt; k &lt;= n;</li><li>又因为h(k) = f(k-1) <em> f(n-k)得到：f(n) = ∑ f(k-1) </em> f(n-k); 0 &lt; k &lt;= n;</li><li>代码：输入n，输出可以构造出的二叉搜索树的数量；</li><li>时间复杂度O(n^3)；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static int BSCount(int n) &#123;</span><br><span class="line">int[] res = new int[n+1];</span><br><span class="line">res[0] = 1;</span><br><span class="line">for(int i = 1; i&lt;=n; i++) &#123;</span><br><span class="line">for(int k=1; k&lt;=i; k++) &#123;</span><br><span class="line">res[i] += res[k-1] * res[i-k];</span><br><span class="line">//System.out.println(i + &quot; k:&quot; + k +&quot; &quot; + res[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res[res.length-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目二：给出一个文本，每行一个单词，10000行以上，将类似与”good”与”godo”与”doog”，也就是单词所包含的字母出现次数一样，这类单词都定义同义词，现在输入一个单词，要求返回该单词的所有同义词；要求查询速度要快。"><a href="#题目二：给出一个文本，每行一个单词，10000行以上，将类似与”good”与”godo”与”doog”，也就是单词所包含的字母出现次数一样，这类单词都定义同义词，现在输入一个单词，要求返回该单词的所有同义词；要求查询速度要快。" class="headerlink" title="题目二：给出一个文本，每行一个单词，10000行以上，将类似与”good”与”godo”与”doog”，也就是单词所包含的字母出现次数一样，这类单词都定义同义词，现在输入一个单词，要求返回该单词的所有同义词；要求查询速度要快。"></a>题目二：给出一个文本，每行一个单词，10000行以上，将类似与”good”与”godo”与”doog”，也就是单词所包含的字母出现次数一样，这类单词都定义同义词，现在输入一个单词，要求返回该单词的所有同义词；要求查询速度要快。</h5><ul><li>解析：这个方法是面试官告诉我的，我自己拿一套就不提了，太傻。<br>首先我们理解诉求，要查询快，当然用哈希表；<br>那么什么东西做key，什么东西做value;<br>因为要返回输入单词的所有同义词，那么value可以是一个字符串类型的数组；<br>我们将所有单个单词都进行排序，那么同义词都长一个样，我们就拿这个排序后的单词做key;</li><li>最难的部分解决了，说说流程；<br>我们需要一个HashMap&lt;String, ArrayList<string>&gt;,value是一个列表；<br>每次从文本读入一个单词，排序后做key,然后存入HashMap；<br>如果key存在，那么获得value的指向的ArrayList,将原本的单词，存入<br>个ArrayList;<br>如果key不存在，那么我们需要新建一个Arraylist,然后将读入的单词存入ArrayList,最后将ArrayList存入HashMap；<br>查询时记得，将输入的单词排序做key去查value;</string></li><li>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package rizhiyi;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Synonym &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">String str = sc.next();</span><br><span class="line">sc.close();</span><br><span class="line">File file = new File(&quot;H:\\java\\example.txt&quot;);</span><br><span class="line">ArrayList&lt;String&gt; arr  = countSameword(str, file);</span><br><span class="line">System.out.println(arr.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static ArrayList&lt;String&gt; countSameword(String s1, File file) throws IOException &#123;</span><br><span class="line">BufferedReader bfr =</span><br><span class="line">new BufferedReader(new FileReader(file));</span><br><span class="line">String line = null;</span><br><span class="line">HashMap&lt;String, ArrayList&lt;String&gt;&gt; map = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();</span><br><span class="line">while((line = bfr.readLine()) != null) &#123;</span><br><span class="line">char[] ch = line.toCharArray();</span><br><span class="line">Arrays.sort(ch);</span><br><span class="line">String str = new String(ch);</span><br><span class="line">if(map.get(str) != null) &#123;</span><br><span class="line">ArrayList&lt;String&gt; value = map.get(str);</span><br><span class="line">value.add(line);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();</span><br><span class="line">arr.add(line);</span><br><span class="line">map.put(str, arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bfr.close();</span><br><span class="line">char[] chRes = s1.toCharArray();</span><br><span class="line">Arrays.sort(chRes);</span><br><span class="line">s1 = new String(chRes);</span><br><span class="line">return map.get(s1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="题目三：给出2-200次最简单的算法，并且证明算法是最简单的。"><a href="#题目三：给出2-200次最简单的算法，并且证明算法是最简单的。" class="headerlink" title="题目三：给出2^200次最简单的算法，并且证明算法是最简单的。"></a>题目三：给出2^200次最简单的算法，并且证明算法是最简单的。</h5><ul><li>这个问题我还没有思路解决在数学上证明方法是最简单的；<br>但是在书上找到了一种相对简单的方法；</li><li>先将200转为二进制表示法，11001000；</li><li><code>2^200 = 2^128 * 2^64 * 2^8;</code><br>在这个过程中我们只需要计算2^1, 2^2, 2^4, 2^8, 2^16, 2^32, 2^64, 2^128,也就是二进制有多少位，我们就需要计算多少次；</li><li>在计算最后结果时，只需要二进制对应是1的地方累乘，计算对应0的地方不需要累乘；</li><li>没有考虑大数</li><li>代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package rizhiyi;</span><br><span class="line">// 求2^50最快捷的方式</span><br><span class="line">public class bigPower &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int n = 50;</span><br><span class="line">String str = Integer.toBinaryString(n);</span><br><span class="line">System.out.println(&quot;二进制表示： &quot; + str);</span><br><span class="line">char[] ch = str.toCharArray();</span><br><span class="line">long[] res = new long[str.length() + 1];</span><br><span class="line">res[0] = 1;</span><br><span class="line">res[1] = 2;</span><br><span class="line">long ans = 1;</span><br><span class="line">for (int i = 2; i &lt;= str.length(); i++) &#123;</span><br><span class="line">res[i] = res[i - 1] * res[i - 1];</span><br><span class="line">&#125;</span><br><span class="line">for (int j = ch.length - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">if (ch[j] == &apos;1&apos;) &#123;</span><br><span class="line">ans *= res[res.length - 1 - j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感谢日志易给的面试机会，感谢技术面大佬；&lt;br&gt;最后厚着脸皮要了个评语：基础知识还行，但是不够熟练;&lt;br&gt;
    
    </summary>
    
      <category term="Interview" scheme="https://kongdada.github.io/categories/Interview/"/>
    
    
      <category term="Interview" scheme="https://kongdada.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>vivo技术面试总结-大数据开发岗</title>
    <link href="https://kongdada.github.io/2018/03/20/vivoInterview/"/>
    <id>https://kongdada.github.io/2018/03/20/vivoInterview/</id>
    <published>2018-03-20T01:59:04.000Z</published>
    <updated>2020-01-13T03:42:26.996Z</updated>
    
    <content type="html"><![CDATA[<p>过了笔试，很幸运的得到了面试机会，背着我的小书包，挤着地铁就去了西土城面试；<br><a id="more"></a></p><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>这部分就不多说了，我说的也不好，大致介绍了一下个人的基本情况；</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>给100W个区间，不重叠。给出一个数N，求这个数在那个区间。空间复杂度要求我看到了，但估计我太菜了，人家没问;<br>给出想法：</li><li>把所有区间的右边界，用一个数组存起来;</li><li>给数组排序;</li><li>二分查找，找到最后一个区间，返回右边界。这就是所在区间的右边界;<br>要求写出大概的代码：<br>现场我没写出来，时间有点紧；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package vivo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">public class search100w &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int n = 89;</span><br><span class="line">int[] arr = &#123;5,10,20,30,40,60,50,55,100,95,90&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">int index = binarySearch(arr,n);</span><br><span class="line">System.out.println(&quot;区间的右边界是： &quot; + arr[index]);</span><br><span class="line">&#125;</span><br><span class="line">private static int binarySearch(int[] arr, int n) &#123;</span><br><span class="line">int low = 0;</span><br><span class="line">int heigh = arr.length-1;</span><br><span class="line">while(low &lt; heigh) &#123;</span><br><span class="line">int mid = (low+heigh)/2;</span><br><span class="line">if(n &lt; arr[mid])</span><br><span class="line">heigh = mid - 1;</span><br><span class="line">else</span><br><span class="line">low = mid + 1;</span><br><span class="line">System.out.println(low +&quot; &quot;+ heigh);</span><br><span class="line">&#125;</span><br><span class="line">return heigh+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><ol><li>接口，抽象类，以及实现，问能不能写一个小栗子，说明一下区别；优缺点，大概这个样子。<br>我大致说了一下，但是没写出小例子;<br>大致区别：<br>接口支持多实现，类不支持多继承，这样接口更利于扩展；<br>实现接口，必须实现接口中的所有方法，继承抽象类，却不一定要实现他的所有方法；<br>接口中成员变量都必须被public static final,成员函数都必须被public abstract修饰，抽象类中可以用public protected default abstract;<br>抽象类的方法可以有默认实现，但是接口不可以;<br>抽象类的速度要比接口快;<br>添加新方法：接口，要添加就必须修改实现类，抽象函数却可以有默认的实现;</li><li>HashMap与HashTable的区别：<br>底层数据结果哈希表，特点和HashMap是一样的;<br>Hashtable线程安全集合，运行速度慢;<br>HashMap线程不安全的集合，运行速度快;<br>Hashtable命运和Vector是一样的，从JDK1.2开始，被更先进的HashMap取代;<br>HashMap允许存储nu11值，nu11键;<br>Hashtable 不允许存储nu11值，nu11键;<br>源码比较：<a href="http://blog.csdn.net/ns_code/article/details/36034955" target="_blank" rel="noopener">http://blog.csdn.net/ns_code/article/details/36034955</a></li><li>HashMap存储，两个键值对中key如果哈希值相同是怎么存储的?<br>哈希值相同，但内容不相同，采用桶存储;<br>哈希值相同，equals()比较内容也相同的话，就不存储，因为这个情况下，key相等，不允许这种情况发生;<br>扩充：<br>HashMap和和Hashtable都是基于哈希表存储数据的，具体就是：内部维护了一个存储数据的Entry数组，HashMap采用链表解决冲突，每一个Entry本质上是一个单向链表。当准备添加一个key-value对时，首先通过hash(key)方法计算hash值，然后通过indexFor(hash,length)求该key-value对的存储位置，计算方法是先用hash&amp;0x7FFFFFFF后，再对length取模，这就保证每一个key-value对都能存入HashMap中，当计算出的位置相同时，由于存入位置是一个链表，则把这个key-value对插入链表头。</li><li>StringBuffer与StringBuilder的比较：<br>前者线程安全，但是速度慢，后者线程不安全，但速度快。<br>StringBuilder类提供与StringBuffer 相同的方法。</li></ol><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>说自己用过的Linux命令：ls ll la, cat more tail, cd, vi, mkdir touch mv cp scp ftp, chomd, cut sed awk;<br>基本就是这样了，这部分平时用就肯定脱口而出，都没问怎么用的，感觉会不会一眼就看得出来;</p><h4 id="自己介绍一下了解的hadoop"><a href="#自己介绍一下了解的hadoop" class="headerlink" title="自己介绍一下了解的hadoop"></a>自己介绍一下了解的hadoop</h4><ul><li>hadoop三个组件，HDFS, MapReduce,Yarn;</li><li>HDFS: 分布式存储框架，namenode, secondnamenode, dataname, 元数据，持久化的命名空间镜像文件，编辑日志。HA高可用;</li><li>MapReduce: map-shuffle-reduce ,shuffle: combiner, partition, sort, copy, sort;</li><li>Yarn: Resouce Manage, Application Manage, Namenode Manage;<br>这一部分我自己了解的比较清楚，名词都大致有个解释。</li></ul><h4 id="地图的导航功能背后是怎么存储数据的额，他又是怎么做到精确导航的；"><a href="#地图的导航功能背后是怎么存储数据的额，他又是怎么做到精确导航的；" class="headerlink" title="地图的导航功能背后是怎么存储数据的额，他又是怎么做到精确导航的；"></a>地图的导航功能背后是怎么存储数据的额，他又是怎么做到精确导航的；</h4><p>没答上来,人家就没扩展直接跳过了；</p><h4 id="笔试的一个题"><a href="#笔试的一个题" class="headerlink" title="笔试的一个题"></a>笔试的一个题</h4><ul><li>寻找最长的重叠字符串，abcabc这种定义位重叠字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package vivo;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">public class FindRepeat &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String str = &quot;abcdefefvivovivoghijghijk&quot;;</span><br><span class="line">char[] ch = str.toCharArray();</span><br><span class="line">System.out.println(Arrays.toString(ch));</span><br><span class="line">String childStr = null;</span><br><span class="line">int maxLength = 0;</span><br><span class="line">String res = null;</span><br><span class="line">for(int i=0; i&lt;ch.length; i++) &#123;</span><br><span class="line">for(int j=i+1; j&lt;=ch.length; j++) &#123;</span><br><span class="line">childStr = new String(ch, i ,j-i);</span><br><span class="line">//System.out.println(childStr);</span><br><span class="line">int first = str.indexOf(childStr);</span><br><span class="line">int last = str.lastIndexOf(childStr);</span><br><span class="line">if(first != last &amp;&amp; childStr.length()&gt;maxLength) &#123;</span><br><span class="line">res = childStr;</span><br><span class="line">//System.out.println(&quot;res :&quot; +res);</span><br><span class="line">maxLength = childStr.length();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过了笔试，很幸运的得到了面试机会，背着我的小书包，挤着地铁就去了西土城面试；&lt;br&gt;
    
    </summary>
    
      <category term="Interview" scheme="https://kongdada.github.io/categories/Interview/"/>
    
    
      <category term="Interview" scheme="https://kongdada.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Get与Post的区别</title>
    <link href="https://kongdada.github.io/2017/12/06/diff-get-post/"/>
    <id>https://kongdada.github.io/2017/12/06/diff-get-post/</id>
    <published>2017-12-06T08:24:07.000Z</published>
    <updated>2020-01-13T03:42:26.991Z</updated>
    
    <content type="html"><![CDATA[<p>先说结论：他们的本质区别在语义上，Get是获取资源，Post是处理资源。<br>由此延伸出来的区别就是：Get是安全的，幂等的，可缓存的。Post不安全的，不幂等的，不可缓存的。<br>安全的：是指他不对服务器资源做任何修改，是一个只读请求，对服务器来说这个请求就是安全的。<br>幂等的：执行一次和多次，效果相同，不对服务器上资源做修改。<a id="more"></a><br>可缓存：这个我不知道怎么解释。<br>至此Get与Post的区别就完了。<br>以下都是自己的理解：<br>Get与Post本质上是http协议中的请求方法，协议是人定的，但是不是所有人有遵守协议就不一定了。<br>如果有人不遵守协议规定的语义，例如使用Get请求去处理资源，用Post请求去请求资源，也就是说Get与Post请求可以去完成对方做的事，只要对应的语法是正确的，服务器就会作出回应。<br>但是这样子做势必会有问题。所表现出来的一些问题，被一部分资料说成了Get与Post的区别。<br>那么人们常常说的Get与Post的哪些区别是什么？我理解这只是他们表现出来的现象上的区别。<br>例如W3c所罗列的：</p><table><thead><tr><th></th><th>Get</th><th>Post</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，Get 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 Post 相比，Get 的安全性较差，因为所发送的数据是 URL 的一部分。发送密码或其他敏感信息时绝不要使用Get ！</td><td>Post 比 Get 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><p>注意！！！</p><ul><li>长度限制，是浏览器对URL长度有限制，而Get方法本身对数据长度是没有限制的。</li><li>安全性，这个现象是存在的，但是个人认为是不按照语义使用相应的请求造成的，Get请求本身就不应该带这些数据与服务器交互。<br>详细参考资料：<br>现象：<a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">点击查看W3c</a><br>本质：<a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="noopener">点击查看博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先说结论：他们的本质区别在语义上，Get是获取资源，Post是处理资源。&lt;br&gt;由此延伸出来的区别就是：Get是安全的，幂等的，可缓存的。Post不安全的，不幂等的，不可缓存的。&lt;br&gt;安全的：是指他不对服务器资源做任何修改，是一个只读请求，对服务器来说这个请求就是安全的。&lt;br&gt;幂等的：执行一次和多次，效果相同，不对服务器上资源做修改。
    
    </summary>
    
      <category term="Http" scheme="https://kongdada.github.io/categories/Http/"/>
    
    
      <category term="Http" scheme="https://kongdada.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>Hive常用命令</title>
    <link href="https://kongdada.github.io/2017/12/01/start-hive/"/>
    <id>https://kongdada.github.io/2017/12/01/start-hive/</id>
    <published>2017-12-01T08:03:21.000Z</published>
    <updated>2020-01-13T03:42:26.995Z</updated>
    
    <content type="html"><![CDATA[<p>Hive 常见命令，老大说学完就给我点权限。<br>你看看，这孩子又在写Bug了。<br><a id="more"></a></p><h4 id="Hive常见命令"><a href="#Hive常见命令" class="headerlink" title="Hive常见命令"></a>Hive常见命令</h4><ul><li>显示所有数据库<br><code>show databases;</code></li><li>指定使用某个数据库<br><code>use database_name;</code></li><li>显示所有表<br><code>show tables;</code></li><li>查询表结构<br><code>desc table_name;</code></li><li>显示表的详细信息<br><code>describe extended table_name;</code></li><li>显示分区信息<br><code>show partitions;</code></li><li><p>HIVEQL创建表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists test_klh (</span><br><span class="line">name string comment &apos;person name&apos;, </span><br><span class="line">age int comment &apos;person age&apos;,</span><br><span class="line">sex string comment &apos;person sex&apos;</span><br><span class="line">)comment &apos;person&apos;</span><br><span class="line">row format delimited</span><br><span class="line"># 列分隔符（字段）</span><br><span class="line">fields terminated by &apos;|&apos;</span><br><span class="line"># 行分隔符</span><br><span class="line">lines terminated by &apos;\n&apos;</span><br><span class="line"># 本地文件的格式</span><br><span class="line">stored as textfile;</span><br></pre></td></tr></table></figure></p></li><li><p>表结构复制，不会复制数据<br><code>create table if not exists test_klh2 like test_klh;</code> </p></li><li>加载数据(将本地数据加载到Hive表)<br><code>load data local inpath &#39;/kehuduan02/bonc_guanjianji/bonc_klh/test&#39; overwrite[可省] into table test_klh;</code></li><li>加载数据同时创建分区<br><code>load data local inpath &#39;path/path&#39; overwrite into table table_name partition (sex, age);</code></li><li>导出数据<br><code>insert overwrite local directory &#39;path&#39; select * from table_name where **</code></li><li>通过查询插入数据<br><code>insert into/overwrite table test_klh select * from test_klh where name = &quot;mike&quot;;</code></li><li>单个查询语句中创建表并加载数据<br><code>create table test_klh1 as select * from test_klh where name = &quot;mike&quot; ;</code></li><li>删除表<br><code>drop table if exitst table_name</code></li><li>case … when … then …<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select name, sex,</span><br><span class="line">case </span><br><span class="line">when test_klh.sex &lt; 22 then &apos;younger&apos; </span><br><span class="line">when test_klh.sex &gt; 20 and test_klh.sex &lt; 23 then &apos;mid&apos;</span><br><span class="line">when test_klh.sex &gt; 22 then &apos;bigger&apos;</span><br><span class="line">else &apos;bingo&apos;</span><br><span class="line">end as bracket from test_klh;</span><br></pre></td></tr></table></figure></li></ul><p>上面这些学完真的就可以去练练手了。</p><h4 id="两个很实用的命令"><a href="#两个很实用的命令" class="headerlink" title="两个很实用的命令"></a>两个很实用的命令</h4><p>下面介绍；两个很实用的命令</p><ul><li><p>hive -e: 在 linux 命令行中执行 hive语句，其实就是用hive来解析hive -e 后面的语句。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@cloud1 hive-0.13.1]# bin/hive -e &apos;select *  from default.student&apos;  </span><br><span class="line">15/10/18 06:55:27 WARN conf.HiveConf: DEPRECATED: hive.metastore.ds.retry.* no longer has any effect.  Use hive.hmshandler.retry.* instead  </span><br><span class="line">Logging initialized using configuration in jar:file:/opt/hive-0.13.1/lib/hive-common-0.13.1.jar!/hive-log4j.properties  </span><br><span class="line">OK  </span><br><span class="line">1   jhon </span><br><span class="line">2   mike  </span><br><span class="line">3   jack  </span><br><span class="line">Time taken: 21.298 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure></p></li><li><p>hive -f：在linux 命令行中执行 hive的.sql文件，其实就是用hive解析一个.sql 文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@cloud1 hive-0.13.1]# touch test.sql  </span><br><span class="line">[root@cloud1 hive-0.13.1]# vi test.sql  </span><br><span class="line">select * from default.student ;   </span><br><span class="line">[root@cloud1 hive-0.13.1]# hive -f /opt/hive-0.13.1/test.sql  </span><br><span class="line">15/10/18 07:00:12 WARN conf.HiveConf: DEPRECATED: hive.metastore.ds.retry.* no longer has any effect.  Use hive.hmshandler.retry.* instead  </span><br><span class="line">Logging initialized using configuration in jar:file:/opt/hive-0.13.1/lib/hive-common-0.13.1.jar!/hive-log4j.properties  </span><br><span class="line">OK  </span><br><span class="line">1   jhon </span><br><span class="line">2   mike  </span><br><span class="line">3   jack </span><br><span class="line">Time taken: 13.048 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure></p></li></ul><p>注意：我一般都把注释写在代码的上一行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hive 常见命令，老大说学完就给我点权限。&lt;br&gt;你看看，这孩子又在写Bug了。&lt;br&gt;
    
    </summary>
    
      <category term="Hive" scheme="https://kongdada.github.io/categories/Hive/"/>
    
    
      <category term="Hive" scheme="https://kongdada.github.io/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>从Hive导出数据到Oracle数据库--Sqoop</title>
    <link href="https://kongdada.github.io/2017/12/01/Hive-Oracle/"/>
    <id>https://kongdada.github.io/2017/12/01/Hive-Oracle/</id>
    <published>2017-12-01T01:48:59.000Z</published>
    <updated>2020-01-13T03:42:26.984Z</updated>
    
    <content type="html"><![CDATA[<p>实习老大让我把Hive中的数据导入Oracle数据库。摸索成功后记录如下：<br>首先解释一下各行代码：<br><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sqoop export</span><br><span class="line"># 指定要从Hive中导出的表</span><br><span class="line">--table TABLE_NAME    </span><br><span class="line"># host_ip:导入oracle库所在的ip:导入的数据库</span><br><span class="line">--connect jdbc:oracle:thin:@HOST_IP:DATABASE_NAME </span><br><span class="line"></span><br><span class="line"># oracle用户账号</span><br><span class="line">--username USERNAME</span><br><span class="line"># oracle用户密码</span><br><span class="line">--password PASSWORD </span><br><span class="line"></span><br><span class="line"># hive表数据文件在hdfs上的路径</span><br><span class="line">--export-dir /user/hive/test/TABLE_NAME</span><br><span class="line"># 指定表的列名，必须指定 </span><br><span class="line">--columns ID,data_date,data_type,c1,c2,c3 </span><br><span class="line"></span><br><span class="line"># 列分隔符(根据hive的表结构定义指定分隔符)</span><br><span class="line">--input-fields-terminated-by &apos;\001&apos;</span><br><span class="line"># 行分隔符</span><br><span class="line">--input-lines-terminated-by &apos;\n&apos; </span><br><span class="line"></span><br><span class="line"># 如果hive表中存在null字段，则需要添加参数，否则无法导入</span><br><span class="line">--input-null-string &apos;\\N&apos; </span><br><span class="line">--input-null-non-string &apos;\\N&apos;</span><br></pre></td></tr></table></figure></p><p>不知道表存在哪儿了: <code>show create table table_name;</code><br>然后来个小栗子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sqoop export \</span><br><span class="line">--connect jdbc:oracle:thin:@172.12.12.102:orcl \</span><br><span class="line">--username test \</span><br><span class="line">--password kong \</span><br><span class="line">--table table_abc \</span><br><span class="line">--export-dir /user/hive/warehouse/bonc_gjj.db/table_abc \</span><br><span class="line"># 注意，这一行columns不能有多余的空格，否则会报错。</span><br><span class="line">--columns zzjgdm,jgmc,jglx,jjlx,frdbhfzr,xzqhdm,yzbm,tzgb,hbzl,jgdz,dh,yxqzfrq,zczj,njq0,fzrq,zzzt,pzwhhzch,bfdw,lastdate,id,dir_id,dir_ver,dir_ver_serail_num,addtime,updatetime,edituser_id,edituser,editdept_id,editdept,inserttype,is_valid,audit_status,pk_md5,sys_encrypt \</span><br><span class="line">--input-fields-terminated-by &apos;\001&apos; \</span><br><span class="line">--input-lines-terminated-by &apos;\n&apos; \</span><br><span class="line">--input-null-string &quot;\\\\N&quot; \</span><br><span class="line">--input-null-non-string &quot;\\\\N&quot;</span><br></pre></td></tr></table></figure></p><p>最后，表那么多，总不能一张一张手动导入吧，那就来个脚本吧。hh<br>脚本奉上，简单的要死，看看就会：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line">a=0;</span><br><span class="line">b=1;</span><br><span class="line"># ``这两个反斜点，就是说里面这是一个变量，我的have_data_table_name是一个文件，里面存的是一堆表名。</span><br><span class="line"># cat file_name，自己试试什么效果。for 开始循环表名。</span><br><span class="line">for table_name in `cat ./have_data_table_name`</span><br><span class="line">    do</span><br><span class="line">    a=`expr $a + $b`</span><br><span class="line">    echo &quot;表名：$table_name,计数：$a&quot;;</span><br><span class="line">    echo  &quot;开始导入数据！&quot;</span><br><span class="line">    # 这一行就厉害了，简单来说就是取出一张表的所有列名，每个列名后加个逗号，然后去掉最后一个逗号，存在col这个变量中。</span><br><span class="line">    col=`hive -e &quot;desc database_name.$&#123;table_name&#125;&quot;|sed &apos;1d&apos;|awk &apos;&#123;printf $1&quot;,&quot;&#125;&apos;|sed &apos;s/,$/\n/g&apos;`</span><br><span class="line"></span><br><span class="line">sqoop export \</span><br><span class="line">--connect jdbc:oracle:thin:@172.12.12.102:1521:orcl \</span><br><span class="line">--username test \</span><br><span class="line">--password kong \</span><br><span class="line">--table $&#123;table_name&#125; \</span><br><span class="line">--export-dir /user/hive/warehouse/database_name.db/$&#123;table_name&#125; \</span><br><span class="line">--columns $&#123;col&#125; \</span><br><span class="line">--input-fields-terminated-by &apos;\001&apos; \</span><br><span class="line">--input-lines-terminated-by &apos;\n&apos; \</span><br><span class="line">--input-null-string &quot;\\\\N&quot; \</span><br><span class="line">--input-null-non-string &quot;\\\\N&quot;</span><br><span class="line"></span><br><span class="line">    echo &quot;第$&#123;a&#125;张表导入完毕！&quot;;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>最后你就可以一边喝茶，一边看电脑跑脚本，数据就这么被导入了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实习老大让我把Hive中的数据导入Oracle数据库。摸索成功后记录如下：&lt;br&gt;首先解释一下各行代码：&lt;br&gt;
    
    </summary>
    
      <category term="Hive" scheme="https://kongdada.github.io/categories/Hive/"/>
    
    
      <category term="Hive" scheme="https://kongdada.github.io/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>伪分布式hadoop2.8.0安装与环境搭建</title>
    <link href="https://kongdada.github.io/2017/11/30/hadoop2-8-0_built/"/>
    <id>https://kongdada.github.io/2017/11/30/hadoop2-8-0_built/</id>
    <published>2017-11-30T07:25:37.000Z</published>
    <updated>2020-01-13T03:42:26.992Z</updated>
    
    <content type="html"><![CDATA[<h4 id="详细教程"><a href="#详细教程" class="headerlink" title="详细教程"></a>详细教程</h4><p>这儿有篇宝典，简单有效，相见恨晚：<a href="https://www.jianyujianyu.com/ubuntu16.04-hadoop2.8.0/" target="_blank" rel="noopener">点击打开宝典</a><br><a id="more"></a></p><h4 id="安装SSH，配置SSH的无密码登录。"><a href="#安装SSH，配置SSH的无密码登录。" class="headerlink" title="安装SSH，配置SSH的无密码登录。"></a>安装SSH，配置SSH的无密码登录。</h4><ul><li>记得先更新一下APT：<code>sudo apt-get update</code></li><li>安装个Vim ：<code>sudo apt-get install vim</code></li><li>安装SSH服务：<code>sudo apt-get  install  openssh-server</code></li><li>安装后登陆一下本机： <code>ssh localhost</code></li><li>这时候是需要密码的，然后退出准备配置无密码登录： exit</li><li>开始:<br>  <code>cd  ~./ssh</code><br>  <code>ssh-keygen  -t  rsa</code>     #一直回车就行<br>  <code>cat  ./id_rsa.pub  &gt;&gt;  ./authorized_keys</code> #加入授权<h4 id="环境配置知识点。"><a href="#环境配置知识点。" class="headerlink" title="环境配置知识点。"></a>环境配置知识点。</h4></li></ul><ol><li>环境变量临时设置，直接在终端输入，属于临时设置。<br><code>export  JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</code><br><code>export PATH=$JAVA_HOME/bin:$PATH</code></li><li>当前用户的全局设置<br>打开~/.bashrc，添加行：<br><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</code><br><code>export PATH=$JAVA_HOME/bin:$PATH</code><br>使生效<br><code>source  ~/.bashrc</code> </li><li>所有用户的全局设置<br><code>$ sudo vim  /etc/profile</code><br><code>export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64</code><br><code>export PATH=$JAVA_HOME/bin:$PATH</code><br>使生效<br><code>source   /etc/profile</code><br>个人建议环境变量用第三种方式配置。</li></ol><ul><li>我的错误：配置环境时在这句中 ： <code>export PATH=$JAVA_HOME/bin:</code> 中没有写最后的$PATH.<br>后果就是所有的命令都无法正常使用了。怎么办呢？命令还在只是计算机没有办法自己找到。那就我们代劳。<br>解决方法：写命令的绝对路径，举个例子，假设 vim 这个命令在 /bin 下那么使用 vim 就要写  ./bin/vim  然后重新编辑环境变量。<h4 id="jps-后没有namenode"><a href="#jps-后没有namenode" class="headerlink" title="jps 后没有namenode"></a>jps 后没有namenode</h4>解决办法：<a href="https://www.zhihu.com/question/31239901" target="_blank" rel="noopener">点击转到解决办法</a><h4 id="hadoop用户"><a href="#hadoop用户" class="headerlink" title="hadoop用户"></a>hadoop用户</h4>最好直接新建 hadoop 用户，不要轻易尝试将当前用户名改为hadoop.这是个大坑，亲测。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;详细教程&quot;&gt;&lt;a href=&quot;#详细教程&quot; class=&quot;headerlink&quot; title=&quot;详细教程&quot;&gt;&lt;/a&gt;详细教程&lt;/h4&gt;&lt;p&gt;这儿有篇宝典，简单有效，相见恨晚：&lt;a href=&quot;https://www.jianyujianyu.com/ubuntu16.04-hadoop2.8.0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击打开宝典&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Hadoop" scheme="https://kongdada.github.io/categories/Hadoop/"/>
    
    
      <category term="hadoop" scheme="https://kongdada.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建过程</title>
    <link href="https://kongdada.github.io/2017/11/22/Blog_built/"/>
    <id>https://kongdada.github.io/2017/11/22/Blog_built/</id>
    <published>2017-11-22T06:11:24.000Z</published>
    <updated>2020-01-13T03:42:26.983Z</updated>
    
    <content type="html"><![CDATA[<h4 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a>个人理解：</h4><p>简单说一下个人对搭建理解：</p><ul><li>github相当于是服务器</li><li>hexo替生成漂亮的页面<a id="more"></a></li><li>通过hexo命令将生成的页面部署（就是上传）到github, github替你将这些页面保存起来。有人访问你的博客，github 就自己发给他。</li></ul><h4 id="搭建过程："><a href="#搭建过程：" class="headerlink" title="搭建过程："></a>搭建过程：</h4><ul><li>博客搭建详细教程：<a href="http://www.jianshu.com/p/f4cc5866946b" target="_blank" rel="noopener">神秘链接</a></li><li>next主题配置教程：<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">神秘链接</a></li><li>搭建过程有上面两个教程就足够了，但是也不妨看看文档。</li><li>Hexo文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">神秘文档</a></li></ul><h4 id="个人遇到的问题："><a href="#个人遇到的问题：" class="headerlink" title="个人遇到的问题："></a>个人遇到的问题：</h4><ol><li>hexo 无法安装，就是命令敲进去了没反应，或者安装一半卡死了。<br> 正常安装Hexo时卡死解决办法：<blockquote><p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>cnpm install hexo-cli -g</p></blockquote></li></ol><h4 id="结束语："><a href="#结束语：" class="headerlink" title="结束语："></a>结束语：</h4><ul><li>新建文章： hexo new title             在本地新建了 .md 文件 </li><li>生成静态页面： hexo generate          在本地生成 html+css+js 文件</li><li>清除生成内容： hexo clean             清除本地生成的文件 </li><li>部署Hexo：hexo deploy                 将本地文件部署到 GitHub</li><li>最后说一句，了解一下超简单的几个MarkDown语法就可以轻松编辑 .md 文件。就是在写文章啦。</li><li><a href="https://kongdada.github.io/2017/11/20/MarkDown/#more">超简单的MarkDown写法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;个人理解：&quot;&gt;&lt;a href=&quot;#个人理解：&quot; class=&quot;headerlink&quot; title=&quot;个人理解：&quot;&gt;&lt;/a&gt;个人理解：&lt;/h4&gt;&lt;p&gt;简单说一下个人对搭建理解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;github相当于是服务器&lt;/li&gt;
&lt;li&gt;hexo替生成漂亮的页面
    
    </summary>
    
      <category term="Blog相关" scheme="https://kongdada.github.io/categories/Blog%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Hexo" scheme="https://kongdada.github.io/tags/Hexo/"/>
    
      <category term="next" scheme="https://kongdada.github.io/tags/next/"/>
    
      <category term="github" scheme="https://kongdada.github.io/tags/github/"/>
    
  </entry>
  
</feed>
