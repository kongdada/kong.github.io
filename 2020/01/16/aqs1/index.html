<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://kongdada.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="我来填坑，第一篇先不讲AQS,打算先说清楚AQS的一些相关知识。这样后续再看AQS会比较容易理解；如果内容有误，麻烦留言斧正，有疑问请关注公众号私信交流共同成长！这一篇主要讲vloatile关键字和Unsafe类。">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="AQS系列之起始篇-volatile和unsafe理解和使用">
<meta property="og:url" content="https://kongdada.github.io/2020/01/16/aqs1/index.html">
<meta property="og:site_name" content="Kong&#39;Blog">
<meta property="og:description" content="我来填坑，第一篇先不讲AQS,打算先说清楚AQS的一些相关知识。这样后续再看AQS会比较容易理解；如果内容有误，麻烦留言斧正，有疑问请关注公众号私信交流共同成长！这一篇主要讲vloatile关键字和Unsafe类。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://kongdada.github.io/uploads/volatile01.png">
<meta property="og:image" content="https://kongdada.github.io/uploads/headpic.jpg">
<meta property="og:updated_time" content="2020-01-20T02:07:43.248Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AQS系列之起始篇-volatile和unsafe理解和使用">
<meta name="twitter:description" content="我来填坑，第一篇先不讲AQS,打算先说清楚AQS的一些相关知识。这样后续再看AQS会比较容易理解；如果内容有误，麻烦留言斧正，有疑问请关注公众号私信交流共同成长！这一篇主要讲vloatile关键字和Unsafe类。">
<meta name="twitter:image" content="https://kongdada.github.io/uploads/volatile01.png">

<link rel="canonical" href="https://kongdada.github.io/2020/01/16/aqs1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>AQS系列之起始篇-volatile和unsafe理解和使用 | Kong'Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3f7522b0115bb0f5b5d19a5a19a888aa";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kong'Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kongdada.github.io/2020/01/16/aqs1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/headpic.jpg">
      <meta itemprop="name" content="Waterkong">
      <meta itemprop="description" content="充满激情，也保持克制">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kong'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AQS系列之起始篇-volatile和unsafe理解和使用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-16 17:57:26" itemprop="dateCreated datePublished" datetime="2020-01-16T17:57:26+08:00">2020-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-20 10:07:43" itemprop="dateModified" datetime="2020-01-20T10:07:43+08:00">2020-01-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/01/16/aqs1/" class="post-meta-item leancloud_visitors" data-flag-title="AQS系列之起始篇-volatile和unsafe理解和使用" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/01/16/aqs1/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/16/aqs1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>我来填坑，第一篇先不讲AQS,打算先说清楚AQS的一些相关知识。这样后续再看AQS会比较容易理解；如果内容有误，麻烦留言斧正，有疑问请关注公众号私信交流共同成长！<br>这一篇主要讲vloatile关键字和Unsafe类。<br><a id="more"></a></p>
<h4 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h4><p>我们都知道volatile关键字，是通过内存屏障实现了两个特性：</p>
<ul>
<li>可见性：假设两个线程A和B同时从主内存中读取了同一个变量c，线程A修改了变量c，会及时写回主内存，并且使线程B持有的变量c失效，然后线程B从主内存读取到被线程A修改过的变量。这样就保证了可见性；</li>
<li>避免指令重排序，这个就是在volatile变量前后加了内存屏障，可以当成一个标识，在这个标识前后的指令，不能进行重排序。</li>
</ul>
<h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>来看第一段代码，证明一下可见性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileTest2 &#123;</span><br><span class="line">    private static volatile Integer c = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (c == 0) &#123;</span><br><span class="line">                    System.out.println(&quot;ac = &quot; + c);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(&quot;bc = &quot; + c);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            c = 1;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ac = 0</span><br><span class="line">ac = 0</span><br><span class="line">ac = 0</span><br><span class="line">ac = 0</span><br><span class="line">ac = 0</span><br><span class="line">ac = 0</span><br><span class="line">ac = 0</span><br><span class="line">ac = 0</span><br><span class="line">bc = 1</span><br></pre></td></tr></table></figure></p>
<p>同时起了两个线程，一个线程对volatile变量的修改，对于另一个线程来说是可见的。</p>
<h5 id="避免重排序"><a href="#避免重排序" class="headerlink" title="避免重排序"></a>避免重排序</h5><p>第二段代码，想说明的是volatile修饰的变量不仅影响变量自身，而且会影响他前后变量。这个也就是volatile会避免指令重排序这个特性的解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileTest4 &#123;</span><br><span class="line">    // a不使用volatile修饰</span><br><span class="line">    public static long a = 0;</span><br><span class="line">    // 消除缓存行的影响</span><br><span class="line">    public static long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">    // b使用volatile修饰</span><br><span class="line">    public static volatile long b = 0;</span><br><span class="line">    // 消除缓存行的影响</span><br><span class="line">    public static long q1, q2, q3, q4, q5, q6, q7;</span><br><span class="line">    // c不使用volatile修饰</span><br><span class="line">    public static long c = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (a == 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">//                    long x = b;</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;a=&quot; + a);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (c == 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    long x = b;</span><br><span class="line">                &#125; catch (Exception ex) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;c=&quot; + c);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        a = 1;</span><br><span class="line">        b = 1;</span><br><span class="line">        c = 1;</span><br><span class="line">        System.out.println(&quot;main end&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main end</span><br><span class="line">c=1</span><br></pre></td></tr></table></figure></p>
<p>上面提到的消除缓存行的影响，如果感兴趣可以搜索关键词“伪共享”去了解。<br>再说回这段代码：</p>
<ol>
<li>同时启动两个线程，然后主线程休眠100毫秒，这个主要为了保证两个子线程都已经启动了。</li>
<li>主线程分别修改abc三个变量的值，b是volatile修饰的，所以两个子线程是可见这个这个变量的改变的。但是ac两个变量对于子线程来说，是不可见的，两个子线程分别持有的a和c的值目前还是0；</li>
<li>但是当子线程再次访问了变量b( long x = b;)，我们发现子线程持有的变量c居然是1了。这就证明了volatile变量不但对自己本身有影响并且对执行到的上下行也有影响；</li>
</ol>
<p>我们来看张图，是volatile变量对前后执行行的影响：<br><img src="\uploads\volatile01.png" alt></p>
<ol start="4">
<li>由此，个人理解是第一项是读取volatile变量b，第二项是读取一般变量c，此时要避免重排序，在这两个指令之间必然会有内存屏障；</li>
<li>内存屏障的作用：不管读还是写，都会把当前缓冲区给刷新，刷新了缓冲区自然拿到了变量c的最新值1；<br>TIPS: 在这一类跟高速缓冲区有关的测试代码中，要仔细思考 System.out.println 的使用时机，因为println方法的底层使用了synchronized关键字，这个关键字也会刷新当前缓冲区，这样会对你的实验造成影响：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void println(String x) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h4><p>这个类在AQS中起到了很大的作用,我们要使用他的CAS和挂起线程唤醒线程；</p>
<h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>他提供了现成的CAS方法：先比较再重置，比如对变量a的更新，分三步：</p>
<ol>
<li>从主内存读取a；</li>
<li>将读取到的a改变;</li>
<li>将改变后的a写回主内存之前，先判断主内存中的a跟自己一开始读取到的a是相等的。确认这个条件后，将改变后的a写入主内存；<br>CAS能够保证在并发环境下，我们正确的更新变量：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    private volatile int count = 0;</span><br><span class="line">    private static long offset;</span><br><span class="line">    private static Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            unsafe = (Unsafe) f.get(null);</span><br><span class="line">            // 获得count的存储位置</span><br><span class="line">            offset = unsafe.objectFieldOffset(Counter.class.getDeclaredField(&quot;count&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void increment() &#123;</span><br><span class="line">        int before = count;</span><br><span class="line">        while (!unsafe.compareAndSwapInt(this, offset, before, before + 1)) &#123;</span><br><span class="line">            System.out.println(&quot;increment &quot; + count);</span><br><span class="line">            before = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Counter counter = new Counter();</span><br><span class="line">        ExecutorService threadPool = new ThreadPoolExecutor(12, 20, 5,</span><br><span class="line">                TimeUnit.SECONDS, new ArrayBlockingQueue(100));</span><br><span class="line">        // 起100个线程，每个线程自增1000次</span><br><span class="line">        IntStream.range(0, 100).forEach(i -&gt; &#123;</span><br><span class="line">            threadPool.submit(() -&gt; IntStream.range(0, 1000).forEach(j -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;-----&quot; + j);</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        // 打印100000</span><br><span class="line">        System.out.println(&quot;count &quot; + counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>CAS操作包含三个操作数 – 内存位置、预期原值及新值。执行CAS操作的时候，将内存位置(offset)的值(count)与预期原值(before)比较，如果相匹配，那么处理器会将该位置值更新为新值，否则，处理器不做任何操作，该方法返回false;<br>测试代码是起了100个线程，每个线程对count自增1000次，如果每一次自增都是正确的，最终count是100*1000。可以自己跑一下，测试；<br>tip: 这一段代码要注意的是我们是通过Unsafe类的theUnsafe字段，通过反射获取到一个unsafe对象；其次就是这个unsafe.compareAndSwapInt()方法；注意参数代表的意义；</p>
<h5 id="park和unpark"><a href="#park和unpark" class="headerlink" title="park和unpark"></a>park和unpark</h5><p>阻塞和唤醒当前线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void finallyTest() throws Exception &#123;</span><br><span class="line">    Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">    f.setAccessible(true);</span><br><span class="line">    Unsafe unsafe = (Unsafe) f.get(null);</span><br><span class="line"></span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;try me&quot;);</span><br><span class="line">            unsafe.park(false,0L);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;finally&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(10);</span><br><span class="line">    System.out.println(&quot;main end&quot;);</span><br><span class="line">    unsafe.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">try me</span><br><span class="line">main end</span><br></pre></td></tr></table></figure></p>
<p>这段代码中:</p>
<ol>
<li>我们启动一个线程打印“try me”之后挂起。</li>
<li>主线程休眠10毫秒，这是为了保证子线程能够执行到挂起那一段代码；主线程打印“main end”之后再唤醒子线程;</li>
<li>子线程唤醒后继续执行打印“finally”;</li>
</ol>
<h4 id="写一个锁"><a href="#写一个锁" class="headerlink" title="写一个锁"></a>写一个锁</h4><p>看明白了以上两个神器，我们就可以尝试写一个锁；<br>想想看我们的锁需要什么？</p>
<ol>
<li>我们需要一个变量state作为标识，标识我这个锁有没有被占用；这个变量还必须声明成volatile的，这个变量的改变要保证所有线程可见；</li>
<li>我们需要一个队列，当有并发获取锁的时候，只有一个线程能获取到，其他线程要被阻塞在这个队列中，然后等待被唤醒；我们使用一个双向链表来做这个队列，队列的每一个节点Node要有三个属性，能保存Thread保存指向前一个节点的指针prev，指向后一个节点的指针next;</li>
<li>并发更新标识变量和并发更新阻塞队列都需要使用CAS更新来保证正确性，我们还要使用线程的挂起与唤醒，所以我们得有一个unsafe对象；</li>
</ol>
<p>首先是Node，阻塞队列的节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 存储的元素为线程</span><br><span class="line">     */</span><br><span class="line">    Thread thread;</span><br><span class="line">    /**</span><br><span class="line">     * 前一个节点（可以没有，但实现起来很困难）</span><br><span class="line">     */</span><br><span class="line">    Node prev;</span><br><span class="line">    /**</span><br><span class="line">     * 后一个节点</span><br><span class="line">     */</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    public Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Node(Thread thread, Node prev) &#123;</span><br><span class="line">        this.thread = thread;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后实现锁：<br>属性有: </p>
<ul>
<li>一个标识变量state，被volatiel修饰；</li>
<li>阻塞队列的首尾指针head tail；</li>
<li>一个unsafe对象；</li>
<li>state的偏移量stateOffset<br>方法有：</li>
<li>构造方法，负责初始化阻塞队列的首尾指针；</li>
<li>加锁lock;</li>
<li>释放锁unlock;</li>
<li>加入阻塞队列抽成一个方法enqueue;</li>
</ul>
<p>具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">public class MyLock &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 用来标识锁有没有被占用</span><br><span class="line">     */</span><br><span class="line">    private volatile int state;</span><br><span class="line">    /**</span><br><span class="line">     * 用它实现CAS操作和操作线程</span><br><span class="line">     */</span><br><span class="line">    private static Unsafe unsafe;</span><br><span class="line">    private static long stateOffset;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 链表头</span><br><span class="line">     */</span><br><span class="line">    private volatile Node head;</span><br><span class="line">    /**</span><br><span class="line">     * 链表尾</span><br><span class="line">     */</span><br><span class="line">    private volatile Node tail;</span><br><span class="line">    private static long tailOffset;</span><br><span class="line">    static final Node EMPTY = new Node();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            unsafe = (Unsafe) f.get(null);</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset(MyLock.class.getDeclaredField(&quot;state&quot;));</span><br><span class="line">            tailOffset = unsafe.objectFieldOffset(MyLock.class.getDeclaredField(&quot;tail&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyLock() &#123;</span><br><span class="line">        head = tail = EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 原子更新锁状态</span><br><span class="line">     *</span><br><span class="line">     * @param expect</span><br><span class="line">     * @param update</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对队尾的原子操作</span><br><span class="line">     *</span><br><span class="line">     * @param expect</span><br><span class="line">     * @param update</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private boolean compareAndSetTail(Node expect, Node update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapObject(this, tailOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private synchronized void printQueue() &#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        while (Objects.nonNull(temp.next)) &#123;</span><br><span class="line">            System.out.print(temp.next.thread.getName() + &quot;##&quot;);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 入队</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Node enqueue() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 获取尾节点</span><br><span class="line">            Node t = tail;</span><br><span class="line">            // 构造新节点</span><br><span class="line">            Node node = new Node(Thread.currentThread(), t);</span><br><span class="line">            // 不断尝试原子更新尾节点</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                // 更新尾节点成功了，让原尾节点的next指针指向当前节点</span><br><span class="line">                t.next = node;</span><br><span class="line"></span><br><span class="line">//                printQueue();</span><br><span class="line"></span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加锁</span><br><span class="line">     */</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        // 尝试更新state字段，更新成功说明占有了锁</span><br><span class="line">        if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;lock&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         *  未更新成功则入队，所有没获得锁的线程都会重复执行入队，直到成功入队</span><br><span class="line">         *  也就是所有没获得锁的线程，都会阻塞在入队操作</span><br><span class="line">         */</span><br><span class="line">        Node node = enqueue();</span><br><span class="line">        Node prev = node.prev;</span><br><span class="line">        // 再次尝试获取锁，需要检测上一个节点是不是head，</span><br><span class="line">        while (node.prev != head || !compareAndSetState(0, 1)) &#123;</span><br><span class="line">            // 未获取到锁，阻塞</span><br><span class="line">            unsafe.park(false, 0L);</span><br><span class="line">        &#125;</span><br><span class="line">        /**下面不需要原子更新，因为同时只有一个线程访问到这里</span><br><span class="line">         * 到这里的条件是：上一个节点是head，并且获得了锁</span><br><span class="line">         * head后移一位，其实就是head要出队</span><br><span class="line">         */</span><br><span class="line">        head = node;</span><br><span class="line">        // 清空当前节点的内容，协助GC</span><br><span class="line">        node.thread = null;</span><br><span class="line">        node.prev = null;</span><br><span class="line">        prev.next = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解锁</span><br><span class="line">     */</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        // 把state更新成0，这里不需要原子更新，因为同时只有一个线程访问到这里</span><br><span class="line">        state = 0;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;unlock&quot;);</span><br><span class="line">        // 下一个待唤醒的节点</span><br><span class="line">        Node next = head.next;</span><br><span class="line">        // 下一个节点不为空，就唤醒它</span><br><span class="line">        if (next != null) &#123;</span><br><span class="line">            unsafe.unpark(next.thread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        MyLock myLock = new MyLock();</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(1000);</span><br><span class="line">        IntStream.range(0, 1000).forEach(i -&gt; new Thread(() -&gt; &#123;</span><br><span class="line">            myLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                IntStream.range(0, 1000).forEach(j -&gt; &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                myLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;, &quot;tt-&quot; + i).start());</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>加锁：<br>假设有三个线程一起执行加锁：</li>
</ul>
<ol>
<li>因为有并发所以使用CAS去更新state,只有一个线程A成功将state更新成了1，占有了锁，线程B跟线程C只好去阻塞在队列中；</li>
<li>线程B和线程C都将自己包装成一个Node挂载在队列的尾结点上；入队还是一个并发操作，所以也要使用CAS去更新tail变量，更新成功的就成功入队，失败的自旋尝试入队，直到成功加入阻塞队列</li>
<li>假设线程B先入队，然后先需要先判断一下自己的前一个节点是不是头结点，如果他的前一个节点不是head，直接阻塞；线程B到此挂起；如果前一个节点是头结点，那么自己是阻塞的第一个线程，可以再次尝试获取一次锁；获取锁失败，也挂起自己；</li>
<li>线程在哪阻塞，被唤醒就会继续执行，所以这一块也要考虑到唤醒之后，要做的动作，理论上被唤醒的应该是第一个阻塞的线程，所以唤醒后也要再次去获取锁；</li>
<li>假设被唤醒后，也成功获得了锁，当前要把head节点向后移动一位，也就是将自己出队，然后帮助GC，把用不到的变量赋值成null;</li>
</ol>
<ul>
<li>释放锁：<br>释放锁不会有并发，因为只有持有锁，我们才会去释放锁，这儿不讨论，不持有锁的线程去释放锁。因为只是自己写得例子，在实际的AQS实现中，必然是先要确认当前线程必须要持有锁。</li>
</ul>
<ol>
<li>将state直接更新为0，代表释放锁；</li>
<li>判断阻塞队列中是否还设有阻塞的线程，如果有则唤醒它；</li>
</ol>
<ul>
<li>怎么验证我们写得锁是不是好用呢？<br>在测试类中起1000个线程，每一个线程都先获取锁，然后对初始化为0的静态变量count，做1000次自增运算，然后释放锁；<br>如果我们写得锁没有问题，自然应该输出1000*1000；<br>测试输出结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#省略一部分打印的日志</span><br><span class="line">tt-995lock</span><br><span class="line">tt-995unlock</span><br><span class="line">tt-987lock</span><br><span class="line">tt-987unlock</span><br><span class="line">1000000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="END"><a href="#END" class="headerlink" title="END"></a>END</h5><p>第一篇到此为止，看到这里其实已经掌握了AQS最核心的那一部分；<br>后面会结合着ReentrantLock和ReentrantReadWriteLock以及CountDownLatch来说一说源代码的具体实现；<br>欢迎公众号一起交流：<br><img src="\uploads\headpic.jpg" alt></p>
<h4 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h4><p><a href="https://tech.meituan.com/2014/09/23/java-memory-reordering.html" target="_blank" rel="noopener">Java内存访问重排序的研究</a><br><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html" target="_blank" rel="noopener">Java魔法类：Unsafe应用解析</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/11/json4spring/" rel="prev" title="前端json传参，后端spring如何承接">
      <i class="fa fa-chevron-left"></i> 前端json传参，后端spring如何承接
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-关键字"><span class="nav-number">1.</span> <span class="nav-text">volatile 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#可见性"><span class="nav-number">1.1.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#避免重排序"><span class="nav-number">1.2.</span> <span class="nav-text">避免重排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unsafe类"><span class="nav-number">2.</span> <span class="nav-text">Unsafe类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CAS"><span class="nav-number">2.1.</span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#park和unpark"><span class="nav-number">2.2.</span> <span class="nav-text">park和unpark</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写一个锁"><span class="nav-number">3.</span> <span class="nav-text">写一个锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#END"><span class="nav-number">3.1.</span> <span class="nav-text">END</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#推荐资料"><span class="nav-number">4.</span> <span class="nav-text">推荐资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Waterkong"
      src="/uploads/headpic.jpg">
  <p class="site-author-name" itemprop="name">Waterkong</p>
  <div class="site-description" itemprop="description">充满激情，也保持克制</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kongdada" title="GitHub → https://github.com/kongdada" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http:/blog.csdn.net/waterkong" title="http:/blog.csdn.net/waterkong" rel="noopener" target="_blank">CSDN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.zhihu.com/people/kong-ling-hui-94/activities" title="https://www.zhihu.com/people/kong-ling-hui-94/activities" rel="noopener" target="_blank">知乎</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tensory.online/" title="http://tensory.online/" rel="noopener" target="_blank">Tensory</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Waterkong</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=qpetg5XTkH9AOlcKxBRsJ9pC-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'qpetg5XTkH9AOlcKxBRsJ9pC-gzGzoHsz',
            'X-LC-Key': 'Bg1GPag7MFxV88X2phtwhoOR',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'qpetg5XTkH9AOlcKxBRsJ9pC-gzGzoHsz',
      appKey: 'Bg1GPag7MFxV88X2phtwhoOR',
      placeholder: "Just go go",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
